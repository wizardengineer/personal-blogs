<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/a3c9030828aa324d.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-01f3c649bd957bd0.js"/><script src="/_next/static/chunks/fd9d1056-749e5812300142af.js" async=""></script><script src="/_next/static/chunks/117-1c2f6535b5c3c811.js" async=""></script><script src="/_next/static/chunks/main-app-f19f44e88293da7f.js" async=""></script><script src="/_next/static/chunks/972-5ecfbe0c89e84126.js" async=""></script><script src="/_next/static/chunks/app/layout-6ab51d7da38697aa.js" async=""></script><title>Wizard Engineer</title><meta name="description" content="Julius’s blog about compilers, security, engineering &amp; more"/><link rel="shortcut icon" href="/wizard.svg"/><link rel="icon" href="/wizard.svg" type="image/svg+xml"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased"><nav class="w-full border-b bg-white"><div class="max-w-4xl mx-auto flex items-center justify-between py-4 px-6"><a class="text-xl font-semibold" href="/">Julius Alexandre</a><ul class="flex space-x-6"><li><a class="hover:underline" href="/blog">Blog</a></li><li><a class="hover:underline" href="/about">About</a></li></ul></div></nav><main class="max-w-3xl mx-auto px-4 py-8"><article class="py-12"><h1 class="text-5xl font-semibold mb-2">AMD-V Hypervisor Development - A Brief Explanation</h1><div class="text-gray-500 mb-8">Aug 22, 2022</div><div class="prose prose-lg"><h2>Motativation</h2>
<p>This was apart of my "Understanding of OS theoretical concepts" and emulator series. I enjoy my time with this project, if you're interested in AMD virtualization then read chapter 15 of the AMD manual. There was also a lack of complacent, with the amount of menial projects I've accomplished. I wanted to hit the bigger fish, something more precedence than my former projects, that was going to be considerable harder. I hope this was helpful for any others whom might decide to make an AMD Hypervisor.</p>
<p><a href="https://github.com/wizardengineer/krakensvm-mg">KrakenSvm Project</a></p>
<h2>Table of Contents:</h2>
<ul>
<li><a href="#preamble">Preamble</a>
<ul>
<li><a href="#purpose--intentions">Purpose &#x26; Intentions</a></li>
<li><a href="#support">Support</a></li>
</ul>
</li>
<li><a href="#terminology">Terminology</a></li>
</ul>
<ul>
<li><a href="#overview---krakensvm-hypervisor">Overview - KrakenSvm Hypervisor</a>
<ul>
<li><a href="#virtual-machine-control-block-vmcb---parts">Virtual Machine Control Block (VMCB) - Parts</a>
<ul>
<li><a href="#control-area">Control Area</a></li>
<li><a href="#save-state-area">Save State Area</a></li>
</ul>
</li>
<li><a href="#secure-virtual-machine-svm---semantics">Secure Virtual Machine (SVM) - Semantics</a>
<ul>
<li><a href="#checking-locksupport-bits">Checking Lock/Support Bits</a></li>
<li><a href="#initializing-vmcb">Initializing VMCB</a></li>
<li><a href="#setting-efersvme">Setting EFER.SVME</a></li>
</ul>
</li>
<li><a href="#secure-virtual-machine-svm---instruction-set">Secure Virtual Machine (SVM) - Instruction Set</a></li>
</ul>
</li>
<li><a href="#credit---special-thanks">Credit - Special Thanks</a></li>
<li><a href="#reference---resource-i-relied-on">Reference - Resource I relied on</a></li>
</ul>
<h1>Preamble</h1>
<h2>Purpose &#x26; Intentions</h2>
<p>There wasn't many, if any amd hypervisors, therefore I created a Proof Of Concept for educational purposes. There was a lack of resource to start someone off on the right foot. This project was to at least help subside any hardship that'll come from a lack resource to rely on.</p>
<h2>Support</h2>
<p>To test on VMWare make sure to turn off Hyper-v on main OS and enable Nested Virtualization on VMWare guest machine if you want to test KrakenSvm.</p>
<h1>Terminology</h1>
<ul>
<li><strong>Guest</strong> - The guest is the virtual machine that will be running on the Hypervisor.</li>
<li><strong>Host</strong> - When Host is used, it's referring the execution context of the Hypervisor.</li>
<li><strong>World Switch</strong> - is the act of switching between Host and Guest. The host will excute VMRUN to start-up or run the Guest. The sequence would usually be Host -> Guest -> Host</li>
<li><strong>vCPUs or CPUs</strong> - when the intel or amd manual discusses about a VMM having a CPUs. It's referring to it having CPU Cores, rather than a single entity CPU.</li>
<li><strong>Nest Page Table (NPT)</strong> - "Nested paging eliminates the overhead caused by VM exits and page table accesses. In essence, with nested page tables the guest can handle paging without intervention from the hypervisor. Nested paging thus significantly improves virtualization performance." By <a href="https://docs.oracle.com/en/virtualization/virtualbox/6.0/admin/nestedpaging.html">Oracle® VM VirtualBox</a></li>
<li><strong>Intercepting</strong> - In terms of Hypervisors, intercepting is the concept and process of having a consistent view of the virtual processor that is visible to the Guest OS. Any intercept that happens triggers a #VMEXIT on the Guest.</li>
</ul>
<blockquote>
<p>Various instructions and events (such as exceptions) in the
guest can be intercepted by means of control bits in the VMCB.
The two primary classes of intercepts supported by SVM are
instruction and exception intercepts.</p>
</blockquote>
<ul>
<li><strong>Virtual Memory Control Block (VMCB)</strong> - Hold information for the VMM and the Guest For intel this would be called VMCS</li>
<li><strong>Virtual Machine Monitor (VMM)</strong> - "also known as a hypervisor, consists of software that controls the execution of multiple guest operating systems on a single physical machine." By <a href="https://www.amd.com/system/files/TechDocs/24593.pdf">AMD Manual</a></li>
</ul>
<h1>Overview - KrakenSvm Hypervisor</h1>
<p>A simple overview of the Hypervisor Kraken to describe the virtualization process on AMD-v.</p>
<h2>Virtual Machine Control Block (VMCB) - Parts</h2>
<p>The VMCB is a data structure that holds crucial information and data, such as the CPU state and VMM (or Hypervisor) Information that'll correlate to how the Guest operates. Here's a simple VMCB Overview:</p>
<p>The definition of a VMCB Structure:</p>
<p><em>Linux Struct</em></p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__attribute__</span> ((__packed__)) <span class="hljs-type">vmcb_fmt_t</span> 
{
    <span class="hljs-type">control_area_64_t</span> control_area;
    <span class="hljs-type">save_state_64_t</span>   save_state;
};
</code></pre>
<p><em>Windows Struct</em></p>
<pre><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vmcb_fmt_t</span> 
{
    <span class="hljs-type">control_area_64_t</span> control_area;
    <span class="hljs-type">save_state_64_t</span>   save_state;
    <span class="hljs-type">uint8_t</span> reserved[RESERVED_SIZE];
};
</code></pre>
<h2>Control Area</h2>
<p>The Control Area is the data structure that holds and saves information for the Hypervisor. This data structure will determine the heuristic executions and rules for the Guest. For example, the initiation of intercepts will be held in the Intercept data members as bits, in the context of VMCB Initialization, before we even start virtualizing the CPUs. Along with other crucial information like the EXITCODE, that'll describe how and why a #VMEXIT was caused, after, or within the instant of virtualizing the CPUs.</p>
<p><em>Control Area Structure Overview</em></p>
<pre><code class="hljs language-cpp">  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Table B-1. VMCB Layout, Control Area.</span>
  <span class="hljs-comment">//</span>

  <span class="hljs-keyword">typedef</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_control_area_fmt_t</span>
  {
    <span class="hljs-type">_control_area_fmt_t</span>() = <span class="hljs-keyword">default</span>;
    
    <span class="hljs-keyword">union</span>
    {
      <span class="hljs-type">uint64_t</span> intercept_read_cr0  : <span class="hljs-number">16</span>;      <span class="hljs-comment">// +0x000</span>
      <span class="hljs-type">uint64_t</span> intercept_write_cr0 : <span class="hljs-number">16</span>;      <span class="hljs-comment">// +0x002</span>
      <span class="hljs-type">uint64_t</span> intercept_read_dr0  : <span class="hljs-number">16</span>;      <span class="hljs-comment">// +0x004</span>
      <span class="hljs-type">uint64_t</span> intercept_write_dr0 : <span class="hljs-number">16</span>;      <span class="hljs-comment">// +0x006</span>
    };
  
    <span class="hljs-type">uint32_t</span> intercept_exceptions_vector;     <span class="hljs-comment">// +0x008</span>
    <span class="hljs-type">uint32_t</span> intercept_misc_vector_3;         <span class="hljs-comment">// +0x00c</span>
    <span class="hljs-type">uint32_t</span> intercept_misc_vector_4;         <span class="hljs-comment">// +0x010</span>
   
    <span class="hljs-type">uint32_t</span> intercept_misc_vector_5 : <span class="hljs-number">5</span>;     <span class="hljs-comment">// +0x014</span>
    <span class="hljs-type">uint32_t</span> reserved_sbz_1          : <span class="hljs-number">27</span>;
   

    <span class="hljs-type">uint8_t</span> reserved[<span class="hljs-number">0x3b</span> - <span class="hljs-number">0x18</span>];            <span class="hljs-comment">// +0x018–0x03b</span>

    <span class="hljs-type">uint16_t</span> pause_filter_threshold;          <span class="hljs-comment">// +0x03c</span>
    <span class="hljs-type">uint16_t</span> pause_filter_count;              <span class="hljs-comment">// +0x03e</span>

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Physical base address of IOPM (bits 11:0 are ignored.)</span>
    <span class="hljs-comment">// </span>
    
    <span class="hljs-type">uint64_t</span> iopm_base_pa;                    <span class="hljs-comment">// +0x040</span>

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Physical base address of MSRPM (bits 11:0 are ignored.)</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-type">uint64_t</span> msrpm_base_pa;                   <span class="hljs-comment">// +0x048</span>

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// TSC_OFFSET To be added in RDTSC and RDTSCP</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-type">uint64_t</span> tsc_offset;                      <span class="hljs-comment">// +0x050</span>

    <span class="hljs-type">uint64_t</span> guest_asid     : <span class="hljs-number">32</span>;             <span class="hljs-comment">// +0x058</span>
    <span class="hljs-type">uint64_t</span> tlb_control    : <span class="hljs-number">8</span>;
    <span class="hljs-type">uint64_t</span> reserved_sbz_2 : <span class="hljs-number">24</span>;

    <span class="hljs-type">uint64_t</span> virtual_misc_vector;             <span class="hljs-comment">// +0x060</span>
    <span class="hljs-type">uint64_t</span> interrupt_misc_vector;           <span class="hljs-comment">// +0x068</span>
    <span class="hljs-type">uint64_t</span> exitcode;                        <span class="hljs-comment">// +0x070</span>
    <span class="hljs-type">uint64_t</span> exitinfo1;                       <span class="hljs-comment">// +0x078</span>
    <span class="hljs-type">uint64_t</span> exitinfo2;                       <span class="hljs-comment">// +0x080</span>
    <span class="hljs-type">uint64_t</span> exitintinfo;                     <span class="hljs-comment">// +0x088</span>

    <span class="hljs-type">uint64_t</span> enable_misc_vector;              <span class="hljs-comment">// +0x090</span>
    <span class="hljs-type">uint64_t</span> avic_apic_bar;                   <span class="hljs-comment">// +0x098</span>
    <span class="hljs-type">uint64_t</span> guest_pa_ghcb;                   <span class="hljs-comment">// +0x0a0</span>
    <span class="hljs-type">uint64_t</span> eventinj;                        <span class="hljs-comment">// +0x0a8</span>
    <span class="hljs-type">uint64_t</span> nested_page_cr3;                 <span class="hljs-comment">// +0x0b0</span>
    <span class="hljs-type">uint64_t</span> lbr_virtualization_enable;       <span class="hljs-comment">// +0x0b8</span>

    clean_field vmcb_clean_bits;              <span class="hljs-comment">// +0x0c0</span>
    

    <span class="hljs-type">uint64_t</span> n_rip;                           <span class="hljs-comment">// +0x0c8</span>

    <span class="hljs-type">uint8_t</span> numbers_bytes_fetched;            <span class="hljs-comment">// +0x0d0</span>
    <span class="hljs-type">uint8_t</span> guest_intruction_bytes[<span class="hljs-number">15</span>];

    <span class="hljs-type">uint64_t</span> avic_apic_backing_page_pointer;  <span class="hljs-comment">// +0x0e0</span>
    <span class="hljs-type">uint64_t</span> reserved_sbz_3;                  <span class="hljs-comment">// +0x0e8</span>
    <span class="hljs-type">uint64_t</span> avic_logical_table_pointer;      <span class="hljs-comment">// +0x0f0</span>
    <span class="hljs-type">uint64_t</span> avic_physical_table_pointer;     <span class="hljs-comment">// +0x0f8</span>
    <span class="hljs-type">uint64_t</span> reserved_sbz_4;                  <span class="hljs-comment">// +0x100</span>
    <span class="hljs-type">uint64_t</span> vmsa_pointer;                    <span class="hljs-comment">// +0x108</span>
    <span class="hljs-type">uint8_t</span> reserved_sbz_5[<span class="hljs-number">0x400</span> - <span class="hljs-number">0x110</span>];

  } <span class="hljs-type">control_area_64_t</span>, *<span class="hljs-type">pcontrol_area_64_t</span>;
</code></pre>
<h2>Save State Area</h2>
<p>The Save State Area would usually be the second data structure in the VMCB struct. Save State Area holds a subset of our processor state/information for the Guest, that's either being loaded from the VMCB or saved to the VMCB. These acts are derived from <a href="#secure-virtual-machine-svm---instruction-set">VMLOAD</a> and <a href="#secure-virtual-machine-svm---instruction-set">VMSAVE</a> respectively.</p>
<p><em>Save State Area</em></p>
<pre><code class="hljs language-cpp">  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Table B-2. VMCB Layout, State Save Area</span>
  <span class="hljs-comment">//</span>

  <span class="hljs-keyword">typedef</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_save_state_fmt_t</span>
  {
    <span class="hljs-type">_save_state_fmt_t</span>() = <span class="hljs-keyword">default</span>;

    seg_register es;                          <span class="hljs-comment">// +0x000</span>
    seg_register cs;                          <span class="hljs-comment">// +0x010</span>
    seg_register ss;                          <span class="hljs-comment">// +0x020</span>
    seg_register ds;                          <span class="hljs-comment">// +0x030</span>
    seg_register fs;                          <span class="hljs-comment">// +0x040</span>
    seg_register gs;                          <span class="hljs-comment">// +0x050</span>
    seg_register gdtr;                        <span class="hljs-comment">// +0x060</span>
    seg_register ldtr;                        <span class="hljs-comment">// +0x070</span>
    seg_register idtr;                        <span class="hljs-comment">// +0x080</span>
    seg_register tr;                          <span class="hljs-comment">// +0x090</span>

    <span class="hljs-type">uint8_t</span> reserved1[<span class="hljs-number">0xca</span> - <span class="hljs-number">0xa0</span>];           <span class="hljs-comment">// +0x0a0</span>
    <span class="hljs-type">uint8_t</span> cpl;                              <span class="hljs-comment">// +0x0cb</span>
    <span class="hljs-type">uint32_t</span> reserved2;                       <span class="hljs-comment">// +0x0cc</span>
    <span class="hljs-type">uint64_t</span> efer;                            <span class="hljs-comment">// +0x0d0</span>
    <span class="hljs-type">uint8_t</span> reserved3[<span class="hljs-number">0x147</span> - <span class="hljs-number">0xd8</span>];          <span class="hljs-comment">// +0x0d9</span>
    <span class="hljs-type">uint64_t</span> cr4;                             <span class="hljs-comment">// +0x148</span>
    <span class="hljs-type">uint64_t</span> cr3;                             <span class="hljs-comment">// +0x150</span>
    <span class="hljs-type">uint64_t</span> cr0;                             <span class="hljs-comment">// +0x158</span>
    <span class="hljs-type">uint64_t</span> dr7;                             <span class="hljs-comment">// +0x160</span>
    <span class="hljs-type">uint64_t</span> dr6;                             <span class="hljs-comment">// +0x168</span>
    <span class="hljs-type">uint64_t</span> rflags;                          <span class="hljs-comment">// +0x170</span>
    <span class="hljs-type">uint64_t</span> rip;                             <span class="hljs-comment">// +0x178</span>
    <span class="hljs-type">uint8_t</span> reserved4[<span class="hljs-number">0x1d7</span> - <span class="hljs-number">0x180</span>];         <span class="hljs-comment">// +0x180</span>
    <span class="hljs-type">uint64_t</span> rsp;                             <span class="hljs-comment">// +0x1d8</span>
    <span class="hljs-type">uint64_t</span> s_cet;                           <span class="hljs-comment">// +0x1e0</span>
    <span class="hljs-type">uint64_t</span> ssp;                             <span class="hljs-comment">// +0x1e8</span>
    <span class="hljs-type">uint64_t</span> isst_addr;                       <span class="hljs-comment">// +0x1f0</span>
    <span class="hljs-type">uint64_t</span> rax;                             <span class="hljs-comment">// +0x1f8</span>
    <span class="hljs-type">uint64_t</span> star;                            <span class="hljs-comment">// +0x200</span>
    <span class="hljs-type">uint64_t</span> lstar;                           <span class="hljs-comment">// +0x208</span>
    <span class="hljs-type">uint64_t</span> cstar;                           <span class="hljs-comment">// +0x210</span>
    <span class="hljs-type">uint64_t</span> sfmask;                          <span class="hljs-comment">// +0x218</span>
    <span class="hljs-type">uint64_t</span> kernel_gs_base;                  <span class="hljs-comment">// +0x220</span>
    <span class="hljs-type">uint64_t</span> sysenter_cs;                     <span class="hljs-comment">// +0x228</span>
    <span class="hljs-type">uint64_t</span> sysenter_esp;                    <span class="hljs-comment">// +0x230</span>
    <span class="hljs-type">uint64_t</span> sysenter_eip;                    <span class="hljs-comment">// +0x238</span>
    <span class="hljs-type">uint64_t</span> cr2;                             <span class="hljs-comment">// +0x240</span>
    <span class="hljs-type">uint8_t</span> reserved5[<span class="hljs-number">0x267</span> - <span class="hljs-number">0x248</span>];         <span class="hljs-comment">// +0x248</span>
    <span class="hljs-type">uint64_t</span> g_pat;                           <span class="hljs-comment">// +0x268</span>
    <span class="hljs-type">uint64_t</span> dbg_ctrl;                        <span class="hljs-comment">// +0x270</span>
    <span class="hljs-type">uint64_t</span> br_from;                         <span class="hljs-comment">// +0x278</span>
    <span class="hljs-type">uint64_t</span> br_to;                           <span class="hljs-comment">// +0x280</span>
    <span class="hljs-type">uint64_t</span> last_excp_from;                  <span class="hljs-comment">// +0x288</span>
    <span class="hljs-type">uint8_t</span> reserved6[<span class="hljs-number">0x2df</span> - <span class="hljs-number">0x298</span>];         <span class="hljs-comment">// +0x298</span>
    <span class="hljs-type">uint64_t</span> spec_ctrl;                       <span class="hljs-comment">// +0x2e0</span>
    <span class="hljs-type">uint32_t</span> reserved7;                       <span class="hljs-comment">// +0x2e4</span>

  } <span class="hljs-type">save_state_64_t</span>, *<span class="hljs-type">psave_state_64_t</span>;
</code></pre>
<h1>Secure Virtual Machine (SVM) - Semantics</h1>
<p>This isn't the full semantics of an AMD Hypervisor that you'd see in the manual. This will be a brief and small explanation of creating a VMM for AMD CPUs and how I went about making mine. For the sake of not prolonging this article, I omitted some things, such as in-detail memory allocation, MSR Bitmap setup, and other things that can be easily researched.</p>
<h2>Checking Lock/Support Bits</h2>
<p>These bits which are either accessed through an MSR or CPUID determine if the CPU is properly set for virtualization to be supported and doesn't have anything that'll lock or render us incapable of enabling virtualization. Let's look at pseudo-code to understand the algorithm for checking each lock and support bits:
</p>
<pre><code class="hljs language-c">Fn8000_0001_ECX_SVM = (<span class="hljs-number">1UL</span> &#x3C;&#x3C; <span class="hljs-number">2</span>);
Fn8000_000A_EDX_NP  = (<span class="hljs-number">1UL</span> &#x3C;&#x3C; <span class="hljs-number">0</span>);
Fn8000_000A_EDX_SVML= (<span class="hljs-number">1UL</span> &#x3C;&#x3C; <span class="hljs-number">2</span>);
MSR_VM_CR           = <span class="hljs-number">0xC0010114</span>;


<span class="hljs-type">int32_t</span> registers[<span class="hljs-number">4</span>]; <span class="hljs-comment">// Index 0 = EAX, </span>
                      <span class="hljs-comment">// Index 1 = EBX, </span>
		      <span class="hljs-comment">// Index 2 = ECX, </span>
		      <span class="hljs-comment">// Index 3 = EDX</span>

<span class="hljs-comment">// checks to see if the processor supports SVM.</span>
<span class="hljs-comment">// See "SVM: secure virtual machine" in </span>
<span class="hljs-comment">// "CPUID Fn8000_0001_ECX[WDT, SKINIT, OSVW, 3DNowPrefetch, MisAlignSse, SSE4A, ABM, ExtApicSpace]"</span>
<span class="hljs-comment">//</span>
__cpuid(registers, Fn8000_0001_ECX);
<span class="hljs-keyword">if</span> ( (registers[<span class="hljs-number">2</span>] &#x26; Fn8000_0001_ECX_SVM) == <span class="hljs-number">0</span> )
	<span class="hljs-keyword">return</span> SVM_IS_NOT_SUPPORTED_BY_CPU;

<span class="hljs-comment">// checks to see if the processor supports Nested Paging</span>
<span class="hljs-comment">// See "NP: nested paging" in "CPUID Fn8000_000A_EDX[DecodeAssists, FlushByAsid, VmcbClean, TscRateMsr]"</span>
<span class="hljs-comment">//</span>
__cpuid(registers, Fn8000_000A_EDX);
<span class="hljs-keyword">if</span> ( (registers[<span class="hljs-number">3</span>] &#x26; Fn8000_000A_EDX_NP) == <span class="hljs-number">0</span>)
	<span class="hljs-keyword">return</span> SVM_NESTED_PAGING_NOT_SUPPORTED;
	
<span class="hljs-comment">// checks to see if the EFER.SVM can be enabled, if the VM_CR.SVMDIS is set then we can't enable EFER.SVM.</span>
<span class="hljs-keyword">if</span> (__readmsr(vm_cr) &#x26; vm_cr_svmdis) == <span class="hljs-number">0</span>
	<span class="hljs-keyword">return</span> SVM_IS_CAPABLE_OF_BEING_ENABLE;

<span class="hljs-comment">// checks if the user must change a platform firmware setting to enable SVM, if not SVMLock may be unlockable; </span>
<span class="hljs-comment">// consult platform firmware or TPM to obtain the key</span>
<span class="hljs-comment">// See "SVML: SVM lock" in "CPUID Fn8000_000A_EDX[DecodeAssists, FlushByAsid, VmcbClean, TscRateMsr]"</span>
__cpuid(registers, Fn8000_000A_EDX);
<span class="hljs-keyword">if</span> ( (registers[<span class="hljs-number">3</span>] &#x26; Fn8000_000A_EDX_SVML) == <span class="hljs-number">0</span>)
	<span class="hljs-keyword">return</span> SVM_DISABLED_AT_BIOS_NOT_UNLOCKABLE;
<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">return</span> SVM_DISABLED_WITH_KEY;
</code></pre>
<p>We check those bits to determine if our code can continue execution. These bits may not have to check if you are positive that your AMD Processor is up to date and is cable of virtualization; however, I would still recommend checking those bits, for the sake of practicality.
</p>
<h2>Initializing VMCB</h2>
<p>Initializing VMCB is monumental in allowing the Guest and VMM to run properly. The reason we initialize VMCB is to have consistency between the processor state and the guest state. This initialization is the preparation that'll be used for our VMM and Guest execution. This section will be showing the steps of initializing the VMCB. We'll start off by capturing the GDT &#x26; IDT registers, initializing the Guest Intercept fields of the <code>vcpu_data->guest_vmcb.control_area</code> and setting the guest's address space ID (ASID) to 1.</p>
<p>For the following code examples, they'll be stored in <code>vmcb_initialization(...)</code> function.</p>
<p>Lets first demonstrate the code Control Area initialization:</p>
<h3>— Control Area - Interception Fields &#x26; ASID</h3>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_MSR_PROT (1UL &#x3C;&#x3C; 28) <span class="hljs-comment">// MSR_PROT—intercept RDMSR or WRMSR accesses to selected MSRs.</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_CPUID    (1UL &#x3C;&#x3C; 18) <span class="hljs-comment">// Intercept CPUID Instruction.</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_VMRUN    (1UL &#x3C;&#x3C; 0)  <span class="hljs-comment">// Intercept VMRUN instruction.</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_VMMCALL  (1UL &#x3C;&#x3C; 1)  <span class="hljs-comment">// Intercept VMMCALL instruction.</span></span>

<span class="hljs-comment">// This will be explained later on...</span>
<span class="hljs-comment">//</span>
_sgdt(&#x26;gdtr_ptr);
__sidt(&#x26;idtr_ptr);

vcpu_data->guest_vmcb
      .control_area.intercept_misc_vector_3 |= INTERCEPT_MSR_PROT | 
                                               INTERCEPT_CPUID;
vcpu_data->guest_vmcb
      .control_area.intercept_misc_vector_4 |= INTERCEPT_VMRUN;

vcpu_data->guest_vmcb.control_area.guest_asid = <span class="hljs-number">1</span>;
</code></pre>
<p>As you can see, the 32-bit data members <code>intercept_misc_vector_3</code> and <code>intercept_misc_vector_4</code> of Control Area does an OR set certain bits. The data member <code>intercept_misc_vector_3</code> will intercept the <code>INTERCEPT_MSR_PROT</code>and <code>INTERCEPT_CPUID</code>. The first Interception will be used to help determine which MSR will is being rdmsr and wrmsr. This is great because we can filter out which MSR we want to intercept specifically in our MSR Bitmap (that was allocated by the VMM) instead of intercepting every time an MSR rdmsr or wrmsr happens. The second bit that being set is the is <code>INTERCEPT_CPUID</code>, we'll use this interception to help with exiting our Guest and VMM and over the execution in a proper manner. That includes deallocation and giving our host back execution.</p>
<p>Now let's move on to the <code>intercept_misc_vector_4</code> data member. This data member sets the <code>INTERCEPT_VMRUN</code> which is required to be set, otherwise, our Guest won't execute at all. The instruction VMRUN does a Canonicalization and Consistency Checks for guests and #VMEXIT for the host. <code>INTERCEPT_VMRUN</code> not being set is considered to be an illegal guest state combination, subsequently causing a #VMEXIT with error code VMEXIT_INVALID.</p>
<p>The same concept applies to the <code>guest_asid</code>, a consistency check is done to make sure ASID is not set to 0. Otherwise, it'd be considered illegal, causing a #VMEXIT with the error code VMEXIT_INVALID.</p>
<p>You can find the first two data members correspondence in <em><strong>Table B-1. VMCB Layout, Control Area</strong></em> offset <em><strong>00Ch (vector 3)</strong></em> and <em><strong>Table B-1. VMCB Layout, Control Area (continued)</strong></em> offset <em><strong>010h (vector 4)</strong></em>, respectively.</p>
<p>The last part of setting up the Control Area will be to initialize the Msr Permissions Map physical address.</p>
<pre><code class="hljs language-cpp">msrpm_vmcb_pa = <span class="hljs-built_in">MmGetPhysicalAddress</span>(shared_page_info->msrpm_addr).QuadPart;
vcpu_data->guest_vmcb.control_area.msrpm_base_pa = msrpm_vmcb_pa;
</code></pre>
<h3>— Save State - Registers / Descriptor Table Registers / Segment Registers</h3>
<p>Now that we've set up the Control Area for our VMCB, we'll start setting up the Save State by initialization the Control Registers, MSRs, and general-purpose registers.</p>
<pre><code class="hljs language-cpp">vcpu_data->guest_vmcb.save_state.cr0 = <span class="hljs-built_in">uint64_t</span>(__readcr0());
vcpu_data->guest_vmcb.save_state.cr2 = <span class="hljs-built_in">uint64_t</span>(__readcr2());
vcpu_data->guest_vmcb.save_state.cr3 = <span class="hljs-built_in">uint64_t</span>(__readcr3());
vcpu_data->guest_vmcb.save_state.cr4 = <span class="hljs-built_in">uint64_t</span>(__readcr4());
vcpu_data->guest_vmcb.save_state.efer = <span class="hljs-built_in">uint64_t</span>(__readmsr(ia32_efer));

<span class="hljs-comment">// GP Register (where they're suppose to be initialize)</span>
vcpu_data->guest_vmcb.save_state.rsp = host_info.rsp;
vcpu_data->guest_vmcb.save_state.rip = host_info.rip;
vcpu_data->guest_vmcb.save_state.rflags = host_info.eflag;

<span class="hljs-comment">// https://en.wikipedia.org/wiki/Page_attribute_table</span>
vcpu_data->guest_vmcb.save_state.g_pat = __readmsr(ia32_pat)
</code></pre>
<p>As you can see, there's a struct that's being passed to the "GP Register" section called <code>host_info</code>. This was initialize before calling the <code>vmcb_initialization(...)</code> function.</p>
<p>After initialization Control Registers, MSRs, and general purpose registers, we'll start working on the Descriptor Table Registers and Segment Registers.</p>
<pre><code class="hljs language-cpp">vcpu_data->guest_vmcb.save_state.gdtr.base_addr = gdtr_ptr.base;
vcpu_data->guest_vmcb.save_state.gdtr.limit = gdtr_ptr.limit;

vcpu_data->guest_vmcb.save_state.idtr.base_addr = idtr_ptr.base;
vcpu_data->guest_vmcb.save_state.idtr.limit = idtr_ptr.limit;
</code></pre>
<p>We're storing the base and limit of GDT &#x26; IDT registers, into the proper data members of the Save State.</p>
<pre><code class="hljs language-cpp">vcpu_data->guest_vmcb.save_state.es.limit = __segmentlimit(__reades());
vcpu_data->guest_vmcb.save_state.cs.limit = __segmentlimit(__readcs());
vcpu_data->guest_vmcb.save_state.ss.limit = __segmentlimit(__readss());
vcpu_data->guest_vmcb.save_state.ds.limit = __segmentlimit(__readds());
vcpu_data->guest_vmcb.save_state.fs.limit = __segmentlimit(__readfs());
vcpu_data->guest_vmcb.save_state.gs.limit = __segmentlimit(__readgs());

vcpu_data->guest_vmcb.save_state.es.selector = __reades();
vcpu_data->guest_vmcb.save_state.cs.selector = __readcs();
vcpu_data->guest_vmcb.save_state.ss.selector = __readss();
vcpu_data->guest_vmcb.save_state.ds.selector = __readds();
vcpu_data->guest_vmcb.save_state.fs.selector = __readfs();
vcpu_data->guest_vmcb.save_state.gs.selector = __readgs();
</code></pre>
<p>Setting up each segment registers limit and selector for the guest to use.</p>
<pre><code class="hljs language-cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [es_base, es_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __reades());
vcpu_data->guest_vmcb.save_state.es.base_addr = es_base;
vcpu_data->guest_vmcb.save_state.es.attribute.value = es_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [cs_base, cs_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readcs());
vcpu_data->guest_vmcb.save_state.cs.base_addr = cs_base;
vcpu_data->guest_vmcb.save_state.cs.attribute.value = cs_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [ss_base, ss_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readss());
vcpu_data->guest_vmcb.save_state.ss.base_addr = ss_base;
vcpu_data->guest_vmcb.save_state.ss.attribute.value = ss_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [ds_base, ds_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readds());
vcpu_data->guest_vmcb.save_state.ds.base_addr = ds_base;
vcpu_data->guest_vmcb.save_state.ds.attribute.value = ds_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [fs_base, fs_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readfs());
vcpu_data->guest_vmcb.save_state.fs.base_addr = fs_base;
vcpu_data->guest_vmcb.save_state.fs.attribute.value = fs_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [gs_base, gs_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readgs());
vcpu_data->guest_vmcb.save_state.gs.base_addr = gs_base;
vcpu_data->guest_vmcb.save_state.gs.attribute.value = gs_attr;

</code></pre>
<p>This will be the last part of setting up the segment and descriptor registers.</p>
<p>We'll start setting up physical addresses for later use. These data members will be passed through our #VMEXIT handler.
for the <code>host_vmcb_pa</code> load some host state that are not loaded on #VMEXIT, which you can see in <a href="https://github.com/wizardengineer/krakensvm-mg/blob/2980e86d3885a7083e53ee9b445f40713783e1b5/krakensvm/svm/vmexit_handler.cpp#L281">here</a></p>
<pre><code class="hljs language-cpp">host_vmcb_pa  = <span class="hljs-built_in">MmGetPhysicalAddress</span>(&#x26;vcpu_data->host_vmcb).QuadPart;
guest_vmcb_pa = <span class="hljs-built_in">MmGetPhysicalAddress</span>(&#x26;vcpu_data->guest_vmcb).QuadPart;

vcpu_data->guest_vmcb_pa = guest_vmcb_pa;
vcpu_data->host_vmcb_pa  = host_vmcb_pa;
</code></pre>
<p>you can read in my <a href="https://github.com/wizardengineer/krakensvm-mg/blob/f16cb6d2676490be1e1025da976da1d4d99fe62c/krakensvm/svm/vmexecute.asm#L76-L97">vmexecute.asm</a> why the <code>guest_vmcb_pa</code> was needed to be pass through in <code>vcpu_data</code> data structure, to give you an idea on how you'd approach doing utilizing <code>guest_vmcb_pa</code>.</p>
<pre><code class="hljs language-cpu">    __svm_vmsave(guest_vmcb_pa);
   __writemsr(vm_hsave_pa, MmGetPhysicalAddress(&#x26;vcpu_data->host_state_area).QuadPart);
   __svm_vmsave(host_vmcb_pa);
</code></pre>
<p>Now, we'll do a vmsave to restore a subset of cpu information to the processor right before #VMEXIT with the VMLOAD instruction so that the guest can start its execution with saved state. The we write to VM_HSAVE_PA, to assure that the host can resume operation after #VMEXIT. VMRUN saves a subset of host processor state to the host state-save area specified by the physical address in the VM_HSAVE_PA MSR.</p>
<p>Last we'll save some of the current state to VMCB for the host usage. Keep in mind this is loaded after #VMEXIT to reproduce the current state for the host (VMM).</p>
<h2>Setting EFER.SVME</h2>
<p>This is fairly simple, all we'll need to do is set the 13 bit of EFER (if we're counting starting from 1) which is EFER.SVME. In other words (1UL &#x3C;&#x3C; 12).</p>
<pre><code class="hljs language-cpp">__writemsr(ia32_efer, __readmsr(ia32_efer) | ia32_efer_svme);
</code></pre>
<h2>Secure Virtual Machine (SVM) - Instruction Set</h2>
<p>SVM has introduces the following instructions.</p>
<table>
<thead>
<tr>
<th>Amd Mnemonic</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>VMRUN</td>
<td>Performs a world-switch to guest</td>
</tr>
<tr>
<td>VMLOAD</td>
<td>Load additional state from VMCB.</td>
</tr>
<tr>
<td>VMSAVE</td>
<td>Save additional guest state to VMCB.</td>
</tr>
<tr>
<td>CLGI</td>
<td>Clears the global interupt flag (GIF).</td>
</tr>
<tr>
<td>VMMCALL</td>
<td>Provides a mechanism for a guest to explicitly  communicate with the VMM</td>
</tr>
<tr>
<td>INVLPGA</td>
<td>Invalidates the TLB mapping for the  virtual page specified in rAX and the ASID specified in ECX.</td>
</tr>
<tr>
<td>SKINIT</td>
<td>Designed to allows for verifiable startup of  trusted software (such as a VMM), based on  secure hash comparison</td>
</tr>
<tr>
<td>STGI</td>
<td>The STGI instruction sets the global interrupt  flag (GIF) to 1.</td>
</tr>
</tbody>
</table>
<h3>VMSAVE Visual Representation</h3>
<p><img src="https://raw.githubusercontent.com/wizardengineer/krakensvm-mg/main/img/vmsave.drawio.png" alt="VMSAVE"></p>
<h3>VMRUN Visual Representation</h3>
<p><img src="https://raw.githubusercontent.com/wizardengineer/krakensvm-mg/main/img/IntroducingBluePill.ppt.pdf.png" alt="VMRUN"></p>
<p><a href="https://github.com/wizardengineer/krakensvm-mg">KrakenSvm Project</a></p>
<h2>Credit - Special Thanks:</h2>
<p>Thanks to these OGs, for the spark of inspiration/support and just being good friends/acquaintances overall on my continuous effort on this project and for helping me understand certain concepts within HyperVisor development Journey. =)</p>
<ul>
<li><a href="https://twitter.com/_xeroxz?lang=en">xeroxz</a> - Helping explain concepts around HV and allowing me to post my article on his website</li>
<li><a href="https://twitter.com/daax_rynd">Daax</a> - His big brain coming in clutch like always. He's given me a great layout on the semantics of a AMD HyperVisor and his approach on it, sharing resources left and right. Even answered my most trivial questions. Daax never misses</li>
<li><strong>horsie</strong> - sharing some resource</li>
<li><a href="https://github.com/tandasat/SimpleSvm/">tandasat</a> - Amazing resource</li>
<li><a href="https://github.com/irql0">Irql0</a> - explaining certain Windows kernel driver, OS concepts and getting me out of tough assembly problems</li>
<li><a href="https://github.com/iPower">iPower</a> - sharing an approach to hooking System Calls and helping fix my VMCB issues</li>
<li><a href="https://github.com/not-matthias">Matthias</a> - For providing information that lead me on to fixing a VMEXIT_INVALID bug i came across and for going out of his way to even debug my HyperVisor to point logic issues and errors. Thank you so much</li>
<li><a href="#https://github.com/LilPidgey">Snowua</a> for helping proof read this article.</li>
</ul>
<h2>Reference - Resource I relied on:</h2>
<ul>
<li><a href="http://developer.amd.com/wordpress/media/2012/10/254811.pdf">AMD CPUID Specification</a></li>
<li><a href="https://www.amd.com/system/files/TechDocs/24593.pdf">AMD Manual</a></li>
<li><a href="http://www-archive.xenproject.org/files/Xen_PacificaDisclosure_AMD_EWahlig.pdf">AMD Pacifica Docs</a></li>
<li><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">Intel Manual</a></li>
<li><a href="https://githacks.org/_xeroxz/bluepill">Xeroxz Hypervisor</a></li>
<li><a href="https://github.com/irql0/limevisor">Irql Hypervisor</a></li>
<li><a href="https://performancebydesign.blogspot.com/2017/12/hyper-v-architecture-intercepts.html">VMM Intercepts</a></li>
<li><a href="https://nskernel.gitbook.io/kernel-play-guide/kvm/amd-v-and-sev">Kernel Play Guide - AMD-V</a></li>
<li><a href="https://www.n4r1b.com/posts/2019/03/system-calls-on-windows-x64/">System calls on Windows x64</a></li>
<li><a href="https://www.matteomalvica.com/minutes/windows_kernel/">[windows] kernel internals</a></li>
</ul></div></article></main><script src="/_next/static/chunks/webpack-01f3c649bd957bd0.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/a3c9030828aa324d.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n7:I[6423,[],\"\"]\n8:I[8911,[\"972\",\"static/chunks/972-5ecfbe0c89e84126.js\",\"185\",\"static/chunks/app/layout-6ab51d7da38697aa.js\"],\"default\"]\na:I[1060,[],\"\"]\n6:[\"slug\",\"amd-hv\",\"d\"]\nb:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"7HSAWJMj0yIK82aCUKT17\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"amd-hv\"],\"initialTree\":[\"\",{\"children\":[[\"slug\",\"amd-hv\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"amd-hv\\\"}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"amd-hv\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a3c9030828aa324d.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"max-w-3xl mx-auto px-4 py-8\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L9\"],\"globalErrorComponent\":\"$a\",\"missingSlots\":\"$Wb\"}]\n"])</script><script>self.__next_f.push([1,"c:T964b,"])</script><script>self.__next_f.push([1,"\u003ch2\u003eMotativation\u003c/h2\u003e\n\u003cp\u003eThis was apart of my \"Understanding of OS theoretical concepts\" and emulator series. I enjoy my time with this project, if you're interested in AMD virtualization then read chapter 15 of the AMD manual. There was also a lack of complacent, with the amount of menial projects I've accomplished. I wanted to hit the bigger fish, something more precedence than my former projects, that was going to be considerable harder. I hope this was helpful for any others whom might decide to make an AMD Hypervisor.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/wizardengineer/krakensvm-mg\"\u003eKrakenSvm Project\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eTable of Contents:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#preamble\"\u003ePreamble\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#purpose--intentions\"\u003ePurpose \u0026#x26; Intentions\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#support\"\u003eSupport\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#terminology\"\u003eTerminology\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#overview---krakensvm-hypervisor\"\u003eOverview - KrakenSvm Hypervisor\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#virtual-machine-control-block-vmcb---parts\"\u003eVirtual Machine Control Block (VMCB) - Parts\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#control-area\"\u003eControl Area\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#save-state-area\"\u003eSave State Area\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#secure-virtual-machine-svm---semantics\"\u003eSecure Virtual Machine (SVM) - Semantics\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#checking-locksupport-bits\"\u003eChecking Lock/Support Bits\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#initializing-vmcb\"\u003eInitializing VMCB\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#setting-efersvme\"\u003eSetting EFER.SVME\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#secure-virtual-machine-svm---instruction-set\"\u003eSecure Virtual Machine (SVM) - Instruction Set\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#credit---special-thanks\"\u003eCredit - Special Thanks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#reference---resource-i-relied-on\"\u003eReference - Resource I relied on\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003ePreamble\u003c/h1\u003e\n\u003ch2\u003ePurpose \u0026#x26; Intentions\u003c/h2\u003e\n\u003cp\u003eThere wasn't many, if any amd hypervisors, therefore I created a Proof Of Concept for educational purposes. There was a lack of resource to start someone off on the right foot. This project was to at least help subside any hardship that'll come from a lack resource to rely on.\u003c/p\u003e\n\u003ch2\u003eSupport\u003c/h2\u003e\n\u003cp\u003eTo test on VMWare make sure to turn off Hyper-v on main OS and enable Nested Virtualization on VMWare guest machine if you want to test KrakenSvm.\u003c/p\u003e\n\u003ch1\u003eTerminology\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGuest\u003c/strong\u003e - The guest is the virtual machine that will be running on the Hypervisor.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHost\u003c/strong\u003e - When Host is used, it's referring the execution context of the Hypervisor.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWorld Switch\u003c/strong\u003e - is the act of switching between Host and Guest. The host will excute VMRUN to start-up or run the Guest. The sequence would usually be Host -\u003e Guest -\u003e Host\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003evCPUs or CPUs\u003c/strong\u003e - when the intel or amd manual discusses about a VMM having a CPUs. It's referring to it having CPU Cores, rather than a single entity CPU.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNest Page Table (NPT)\u003c/strong\u003e - \"Nested paging eliminates the overhead caused by VM exits and page table accesses. In essence, with nested page tables the guest can handle paging without intervention from the hypervisor. Nested paging thus significantly improves virtualization performance.\" By \u003ca href=\"https://docs.oracle.com/en/virtualization/virtualbox/6.0/admin/nestedpaging.html\"\u003eOracle® VM VirtualBox\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIntercepting\u003c/strong\u003e - In terms of Hypervisors, intercepting is the concept and process of having a consistent view of the virtual processor that is visible to the Guest OS. Any intercept that happens triggers a #VMEXIT on the Guest.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eVarious instructions and events (such as exceptions) in the\nguest can be intercepted by means of control bits in the VMCB.\nThe two primary classes of intercepts supported by SVM are\ninstruction and exception intercepts.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eVirtual Memory Control Block (VMCB)\u003c/strong\u003e - Hold information for the VMM and the Guest For intel this would be called VMCS\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVirtual Machine Monitor (VMM)\u003c/strong\u003e - \"also known as a hypervisor, consists of software that controls the execution of multiple guest operating systems on a single physical machine.\" By \u003ca href=\"https://www.amd.com/system/files/TechDocs/24593.pdf\"\u003eAMD Manual\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eOverview - KrakenSvm Hypervisor\u003c/h1\u003e\n\u003cp\u003eA simple overview of the Hypervisor Kraken to describe the virtualization process on AMD-v.\u003c/p\u003e\n\u003ch2\u003eVirtual Machine Control Block (VMCB) - Parts\u003c/h2\u003e\n\u003cp\u003eThe VMCB is a data structure that holds crucial information and data, such as the CPU state and VMM (or Hypervisor) Information that'll correlate to how the Guest operates. Here's a simple VMCB Overview:\u003c/p\u003e\n\u003cp\u003eThe definition of a VMCB Structure:\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eLinux Struct\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c++\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e__attribute__\u003c/span\u003e ((__packed__)) \u003cspan class=\"hljs-type\"\u003evmcb_fmt_t\u003c/span\u003e \n{\n    \u003cspan class=\"hljs-type\"\u003econtrol_area_64_t\u003c/span\u003e control_area;\n    \u003cspan class=\"hljs-type\"\u003esave_state_64_t\u003c/span\u003e   save_state;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eWindows Struct\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003evmcb_fmt_t\u003c/span\u003e \n{\n    \u003cspan class=\"hljs-type\"\u003econtrol_area_64_t\u003c/span\u003e control_area;\n    \u003cspan class=\"hljs-type\"\u003esave_state_64_t\u003c/span\u003e   save_state;\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e reserved[RESERVED_SIZE];\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eControl Area\u003c/h2\u003e\n\u003cp\u003eThe Control Area is the data structure that holds and saves information for the Hypervisor. This data structure will determine the heuristic executions and rules for the Guest. For example, the initiation of intercepts will be held in the Intercept data members as bits, in the context of VMCB Initialization, before we even start virtualizing the CPUs. Along with other crucial information like the EXITCODE, that'll describe how and why a #VMEXIT was caused, after, or within the instant of virtualizing the CPUs.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eControl Area Structure Overview\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e  \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// Table B-1. VMCB Layout, Control Area.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003etypedef\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_control_area_fmt_t\u003c/span\u003e\n  {\n    \u003cspan class=\"hljs-type\"\u003e_control_area_fmt_t\u003c/span\u003e() = \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e;\n    \n    \u003cspan class=\"hljs-keyword\"\u003eunion\u003c/span\u003e\n    {\n      \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e intercept_read_cr0  : \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e;      \u003cspan class=\"hljs-comment\"\u003e// +0x000\u003c/span\u003e\n      \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e intercept_write_cr0 : \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e;      \u003cspan class=\"hljs-comment\"\u003e// +0x002\u003c/span\u003e\n      \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e intercept_read_dr0  : \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e;      \u003cspan class=\"hljs-comment\"\u003e// +0x004\u003c/span\u003e\n      \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e intercept_write_dr0 : \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e;      \u003cspan class=\"hljs-comment\"\u003e// +0x006\u003c/span\u003e\n    };\n  \n    \u003cspan class=\"hljs-type\"\u003euint32_t\u003c/span\u003e intercept_exceptions_vector;     \u003cspan class=\"hljs-comment\"\u003e// +0x008\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint32_t\u003c/span\u003e intercept_misc_vector_3;         \u003cspan class=\"hljs-comment\"\u003e// +0x00c\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint32_t\u003c/span\u003e intercept_misc_vector_4;         \u003cspan class=\"hljs-comment\"\u003e// +0x010\u003c/span\u003e\n   \n    \u003cspan class=\"hljs-type\"\u003euint32_t\u003c/span\u003e intercept_misc_vector_5 : \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;     \u003cspan class=\"hljs-comment\"\u003e// +0x014\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint32_t\u003c/span\u003e reserved_sbz_1          : \u003cspan class=\"hljs-number\"\u003e27\u003c/span\u003e;\n   \n\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e reserved[\u003cspan class=\"hljs-number\"\u003e0x3b\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0x18\u003c/span\u003e];            \u003cspan class=\"hljs-comment\"\u003e// +0x018–0x03b\u003c/span\u003e\n\n    \u003cspan class=\"hljs-type\"\u003euint16_t\u003c/span\u003e pause_filter_threshold;          \u003cspan class=\"hljs-comment\"\u003e// +0x03c\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint16_t\u003c/span\u003e pause_filter_count;              \u003cspan class=\"hljs-comment\"\u003e// +0x03e\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// Physical base address of IOPM (bits 11:0 are ignored.)\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// \u003c/span\u003e\n    \n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e iopm_base_pa;                    \u003cspan class=\"hljs-comment\"\u003e// +0x040\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// Physical base address of MSRPM (bits 11:0 are ignored.)\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e msrpm_base_pa;                   \u003cspan class=\"hljs-comment\"\u003e// +0x048\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// TSC_OFFSET To be added in RDTSC and RDTSCP\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e tsc_offset;                      \u003cspan class=\"hljs-comment\"\u003e// +0x050\u003c/span\u003e\n\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e guest_asid     : \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e;             \u003cspan class=\"hljs-comment\"\u003e// +0x058\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e tlb_control    : \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e;\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e reserved_sbz_2 : \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e virtual_misc_vector;             \u003cspan class=\"hljs-comment\"\u003e// +0x060\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e interrupt_misc_vector;           \u003cspan class=\"hljs-comment\"\u003e// +0x068\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e exitcode;                        \u003cspan class=\"hljs-comment\"\u003e// +0x070\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e exitinfo1;                       \u003cspan class=\"hljs-comment\"\u003e// +0x078\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e exitinfo2;                       \u003cspan class=\"hljs-comment\"\u003e// +0x080\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e exitintinfo;                     \u003cspan class=\"hljs-comment\"\u003e// +0x088\u003c/span\u003e\n\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e enable_misc_vector;              \u003cspan class=\"hljs-comment\"\u003e// +0x090\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e avic_apic_bar;                   \u003cspan class=\"hljs-comment\"\u003e// +0x098\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e guest_pa_ghcb;                   \u003cspan class=\"hljs-comment\"\u003e// +0x0a0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e eventinj;                        \u003cspan class=\"hljs-comment\"\u003e// +0x0a8\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e nested_page_cr3;                 \u003cspan class=\"hljs-comment\"\u003e// +0x0b0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e lbr_virtualization_enable;       \u003cspan class=\"hljs-comment\"\u003e// +0x0b8\u003c/span\u003e\n\n    clean_field vmcb_clean_bits;              \u003cspan class=\"hljs-comment\"\u003e// +0x0c0\u003c/span\u003e\n    \n\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e n_rip;                           \u003cspan class=\"hljs-comment\"\u003e// +0x0c8\u003c/span\u003e\n\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e numbers_bytes_fetched;            \u003cspan class=\"hljs-comment\"\u003e// +0x0d0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e guest_intruction_bytes[\u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e];\n\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e avic_apic_backing_page_pointer;  \u003cspan class=\"hljs-comment\"\u003e// +0x0e0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e reserved_sbz_3;                  \u003cspan class=\"hljs-comment\"\u003e// +0x0e8\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e avic_logical_table_pointer;      \u003cspan class=\"hljs-comment\"\u003e// +0x0f0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e avic_physical_table_pointer;     \u003cspan class=\"hljs-comment\"\u003e// +0x0f8\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e reserved_sbz_4;                  \u003cspan class=\"hljs-comment\"\u003e// +0x100\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e vmsa_pointer;                    \u003cspan class=\"hljs-comment\"\u003e// +0x108\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e reserved_sbz_5[\u003cspan class=\"hljs-number\"\u003e0x400\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0x110\u003c/span\u003e];\n\n  } \u003cspan class=\"hljs-type\"\u003econtrol_area_64_t\u003c/span\u003e, *\u003cspan class=\"hljs-type\"\u003epcontrol_area_64_t\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSave State Area\u003c/h2\u003e\n\u003cp\u003eThe Save State Area would usually be the second data structure in the VMCB struct. Save State Area holds a subset of our processor state/information for the Guest, that's either being loaded from the VMCB or saved to the VMCB. These acts are derived from \u003ca href=\"#secure-virtual-machine-svm---instruction-set\"\u003eVMLOAD\u003c/a\u003e and \u003ca href=\"#secure-virtual-machine-svm---instruction-set\"\u003eVMSAVE\u003c/a\u003e respectively.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSave State Area\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e  \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// Table B-2. VMCB Layout, State Save Area\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003etypedef\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_save_state_fmt_t\u003c/span\u003e\n  {\n    \u003cspan class=\"hljs-type\"\u003e_save_state_fmt_t\u003c/span\u003e() = \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e;\n\n    seg_register es;                          \u003cspan class=\"hljs-comment\"\u003e// +0x000\u003c/span\u003e\n    seg_register cs;                          \u003cspan class=\"hljs-comment\"\u003e// +0x010\u003c/span\u003e\n    seg_register ss;                          \u003cspan class=\"hljs-comment\"\u003e// +0x020\u003c/span\u003e\n    seg_register ds;                          \u003cspan class=\"hljs-comment\"\u003e// +0x030\u003c/span\u003e\n    seg_register fs;                          \u003cspan class=\"hljs-comment\"\u003e// +0x040\u003c/span\u003e\n    seg_register gs;                          \u003cspan class=\"hljs-comment\"\u003e// +0x050\u003c/span\u003e\n    seg_register gdtr;                        \u003cspan class=\"hljs-comment\"\u003e// +0x060\u003c/span\u003e\n    seg_register ldtr;                        \u003cspan class=\"hljs-comment\"\u003e// +0x070\u003c/span\u003e\n    seg_register idtr;                        \u003cspan class=\"hljs-comment\"\u003e// +0x080\u003c/span\u003e\n    seg_register tr;                          \u003cspan class=\"hljs-comment\"\u003e// +0x090\u003c/span\u003e\n\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e reserved1[\u003cspan class=\"hljs-number\"\u003e0xca\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0xa0\u003c/span\u003e];           \u003cspan class=\"hljs-comment\"\u003e// +0x0a0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e cpl;                              \u003cspan class=\"hljs-comment\"\u003e// +0x0cb\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint32_t\u003c/span\u003e reserved2;                       \u003cspan class=\"hljs-comment\"\u003e// +0x0cc\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e efer;                            \u003cspan class=\"hljs-comment\"\u003e// +0x0d0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e reserved3[\u003cspan class=\"hljs-number\"\u003e0x147\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0xd8\u003c/span\u003e];          \u003cspan class=\"hljs-comment\"\u003e// +0x0d9\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e cr4;                             \u003cspan class=\"hljs-comment\"\u003e// +0x148\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e cr3;                             \u003cspan class=\"hljs-comment\"\u003e// +0x150\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e cr0;                             \u003cspan class=\"hljs-comment\"\u003e// +0x158\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e dr7;                             \u003cspan class=\"hljs-comment\"\u003e// +0x160\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e dr6;                             \u003cspan class=\"hljs-comment\"\u003e// +0x168\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e rflags;                          \u003cspan class=\"hljs-comment\"\u003e// +0x170\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e rip;                             \u003cspan class=\"hljs-comment\"\u003e// +0x178\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e reserved4[\u003cspan class=\"hljs-number\"\u003e0x1d7\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0x180\u003c/span\u003e];         \u003cspan class=\"hljs-comment\"\u003e// +0x180\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e rsp;                             \u003cspan class=\"hljs-comment\"\u003e// +0x1d8\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e s_cet;                           \u003cspan class=\"hljs-comment\"\u003e// +0x1e0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e ssp;                             \u003cspan class=\"hljs-comment\"\u003e// +0x1e8\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e isst_addr;                       \u003cspan class=\"hljs-comment\"\u003e// +0x1f0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e rax;                             \u003cspan class=\"hljs-comment\"\u003e// +0x1f8\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e star;                            \u003cspan class=\"hljs-comment\"\u003e// +0x200\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e lstar;                           \u003cspan class=\"hljs-comment\"\u003e// +0x208\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e cstar;                           \u003cspan class=\"hljs-comment\"\u003e// +0x210\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e sfmask;                          \u003cspan class=\"hljs-comment\"\u003e// +0x218\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e kernel_gs_base;                  \u003cspan class=\"hljs-comment\"\u003e// +0x220\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e sysenter_cs;                     \u003cspan class=\"hljs-comment\"\u003e// +0x228\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e sysenter_esp;                    \u003cspan class=\"hljs-comment\"\u003e// +0x230\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e sysenter_eip;                    \u003cspan class=\"hljs-comment\"\u003e// +0x238\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e cr2;                             \u003cspan class=\"hljs-comment\"\u003e// +0x240\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e reserved5[\u003cspan class=\"hljs-number\"\u003e0x267\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0x248\u003c/span\u003e];         \u003cspan class=\"hljs-comment\"\u003e// +0x248\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e g_pat;                           \u003cspan class=\"hljs-comment\"\u003e// +0x268\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e dbg_ctrl;                        \u003cspan class=\"hljs-comment\"\u003e// +0x270\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e br_from;                         \u003cspan class=\"hljs-comment\"\u003e// +0x278\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e br_to;                           \u003cspan class=\"hljs-comment\"\u003e// +0x280\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e last_excp_from;                  \u003cspan class=\"hljs-comment\"\u003e// +0x288\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint8_t\u003c/span\u003e reserved6[\u003cspan class=\"hljs-number\"\u003e0x2df\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0x298\u003c/span\u003e];         \u003cspan class=\"hljs-comment\"\u003e// +0x298\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint64_t\u003c/span\u003e spec_ctrl;                       \u003cspan class=\"hljs-comment\"\u003e// +0x2e0\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003euint32_t\u003c/span\u003e reserved7;                       \u003cspan class=\"hljs-comment\"\u003e// +0x2e4\u003c/span\u003e\n\n  } \u003cspan class=\"hljs-type\"\u003esave_state_64_t\u003c/span\u003e, *\u003cspan class=\"hljs-type\"\u003epsave_state_64_t\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eSecure Virtual Machine (SVM) - Semantics\u003c/h1\u003e\n\u003cp\u003eThis isn't the full semantics of an AMD Hypervisor that you'd see in the manual. This will be a brief and small explanation of creating a VMM for AMD CPUs and how I went about making mine. For the sake of not prolonging this article, I omitted some things, such as in-detail memory allocation, MSR Bitmap setup, and other things that can be easily researched.\u003c/p\u003e\n\u003ch2\u003eChecking Lock/Support Bits\u003c/h2\u003e\n\u003cp\u003eThese bits which are either accessed through an MSR or CPUID determine if the CPU is properly set for virtualization to be supported and doesn't have anything that'll lock or render us incapable of enabling virtualization. Let's look at pseudo-code to understand the algorithm for checking each lock and support bits:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003eFn8000_0001_ECX_SVM = (\u003cspan class=\"hljs-number\"\u003e1UL\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\nFn8000_000A_EDX_NP  = (\u003cspan class=\"hljs-number\"\u003e1UL\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\nFn8000_000A_EDX_SVML= (\u003cspan class=\"hljs-number\"\u003e1UL\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\nMSR_VM_CR           = \u003cspan class=\"hljs-number\"\u003e0xC0010114\u003c/span\u003e;\n\n\n\u003cspan class=\"hljs-type\"\u003eint32_t\u003c/span\u003e registers[\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// Index 0 = EAX, \u003c/span\u003e\n                      \u003cspan class=\"hljs-comment\"\u003e// Index 1 = EBX, \u003c/span\u003e\n\t\t      \u003cspan class=\"hljs-comment\"\u003e// Index 2 = ECX, \u003c/span\u003e\n\t\t      \u003cspan class=\"hljs-comment\"\u003e// Index 3 = EDX\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// checks to see if the processor supports SVM.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// See \"SVM: secure virtual machine\" in \u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \"CPUID Fn8000_0001_ECX[WDT, SKINIT, OSVW, 3DNowPrefetch, MisAlignSse, SSE4A, ABM, ExtApicSpace]\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n__cpuid(registers, Fn8000_0001_ECX);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ( (registers[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] \u0026#x26; Fn8000_0001_ECX_SVM) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e )\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e SVM_IS_NOT_SUPPORTED_BY_CPU;\n\n\u003cspan class=\"hljs-comment\"\u003e// checks to see if the processor supports Nested Paging\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// See \"NP: nested paging\" in \"CPUID Fn8000_000A_EDX[DecodeAssists, FlushByAsid, VmcbClean, TscRateMsr]\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n__cpuid(registers, Fn8000_000A_EDX);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ( (registers[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] \u0026#x26; Fn8000_000A_EDX_NP) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e SVM_NESTED_PAGING_NOT_SUPPORTED;\n\t\n\u003cspan class=\"hljs-comment\"\u003e// checks to see if the EFER.SVM can be enabled, if the VM_CR.SVMDIS is set then we can't enable EFER.SVM.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (__readmsr(vm_cr) \u0026#x26; vm_cr_svmdis) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e SVM_IS_CAPABLE_OF_BEING_ENABLE;\n\n\u003cspan class=\"hljs-comment\"\u003e// checks if the user must change a platform firmware setting to enable SVM, if not SVMLock may be unlockable; \u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// consult platform firmware or TPM to obtain the key\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// See \"SVML: SVM lock\" in \"CPUID Fn8000_000A_EDX[DecodeAssists, FlushByAsid, VmcbClean, TscRateMsr]\"\u003c/span\u003e\n__cpuid(registers, Fn8000_000A_EDX);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ( (registers[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] \u0026#x26; Fn8000_000A_EDX_SVML) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e SVM_DISABLED_AT_BIOS_NOT_UNLOCKABLE;\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e SVM_DISABLED_WITH_KEY;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe check those bits to determine if our code can continue execution. These bits may not have to check if you are positive that your AMD Processor is up to date and is cable of virtualization; however, I would still recommend checking those bits, for the sake of practicality.\n\u003c/p\u003e\n\u003ch2\u003eInitializing VMCB\u003c/h2\u003e\n\u003cp\u003eInitializing VMCB is monumental in allowing the Guest and VMM to run properly. The reason we initialize VMCB is to have consistency between the processor state and the guest state. This initialization is the preparation that'll be used for our VMM and Guest execution. This section will be showing the steps of initializing the VMCB. We'll start off by capturing the GDT \u0026#x26; IDT registers, initializing the Guest Intercept fields of the \u003ccode\u003evcpu_data-\u003eguest_vmcb.control_area\u003c/code\u003e and setting the guest's address space ID (ASID) to 1.\u003c/p\u003e\n\u003cp\u003eFor the following code examples, they'll be stored in \u003ccode\u003evmcb_initialization(...)\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eLets first demonstrate the code Control Area initialization:\u003c/p\u003e\n\u003ch3\u003e— Control Area - Interception Fields \u0026#x26; ASID\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003edefine\u003c/span\u003e INTERCEPT_MSR_PROT (1UL \u0026#x3C;\u0026#x3C; 28) \u003cspan class=\"hljs-comment\"\u003e// MSR_PROT—intercept RDMSR or WRMSR accesses to selected MSRs.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003edefine\u003c/span\u003e INTERCEPT_CPUID    (1UL \u0026#x3C;\u0026#x3C; 18) \u003cspan class=\"hljs-comment\"\u003e// Intercept CPUID Instruction.\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003edefine\u003c/span\u003e INTERCEPT_VMRUN    (1UL \u0026#x3C;\u0026#x3C; 0)  \u003cspan class=\"hljs-comment\"\u003e// Intercept VMRUN instruction.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003edefine\u003c/span\u003e INTERCEPT_VMMCALL  (1UL \u0026#x3C;\u0026#x3C; 1)  \u003cspan class=\"hljs-comment\"\u003e// Intercept VMMCALL instruction.\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// This will be explained later on...\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n_sgdt(\u0026#x26;gdtr_ptr);\n__sidt(\u0026#x26;idtr_ptr);\n\nvcpu_data-\u003eguest_vmcb\n      .control_area.intercept_misc_vector_3 |= INTERCEPT_MSR_PROT | \n                                               INTERCEPT_CPUID;\nvcpu_data-\u003eguest_vmcb\n      .control_area.intercept_misc_vector_4 |= INTERCEPT_VMRUN;\n\nvcpu_data-\u003eguest_vmcb.control_area.guest_asid = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the 32-bit data members \u003ccode\u003eintercept_misc_vector_3\u003c/code\u003e and \u003ccode\u003eintercept_misc_vector_4\u003c/code\u003e of Control Area does an OR set certain bits. The data member \u003ccode\u003eintercept_misc_vector_3\u003c/code\u003e will intercept the \u003ccode\u003eINTERCEPT_MSR_PROT\u003c/code\u003eand \u003ccode\u003eINTERCEPT_CPUID\u003c/code\u003e. The first Interception will be used to help determine which MSR will is being rdmsr and wrmsr. This is great because we can filter out which MSR we want to intercept specifically in our MSR Bitmap (that was allocated by the VMM) instead of intercepting every time an MSR rdmsr or wrmsr happens. The second bit that being set is the is \u003ccode\u003eINTERCEPT_CPUID\u003c/code\u003e, we'll use this interception to help with exiting our Guest and VMM and over the execution in a proper manner. That includes deallocation and giving our host back execution.\u003c/p\u003e\n\u003cp\u003eNow let's move on to the \u003ccode\u003eintercept_misc_vector_4\u003c/code\u003e data member. This data member sets the \u003ccode\u003eINTERCEPT_VMRUN\u003c/code\u003e which is required to be set, otherwise, our Guest won't execute at all. The instruction VMRUN does a Canonicalization and Consistency Checks for guests and #VMEXIT for the host. \u003ccode\u003eINTERCEPT_VMRUN\u003c/code\u003e not being set is considered to be an illegal guest state combination, subsequently causing a #VMEXIT with error code VMEXIT_INVALID.\u003c/p\u003e\n\u003cp\u003eThe same concept applies to the \u003ccode\u003eguest_asid\u003c/code\u003e, a consistency check is done to make sure ASID is not set to 0. Otherwise, it'd be considered illegal, causing a #VMEXIT with the error code VMEXIT_INVALID.\u003c/p\u003e\n\u003cp\u003eYou can find the first two data members correspondence in \u003cem\u003e\u003cstrong\u003eTable B-1. VMCB Layout, Control Area\u003c/strong\u003e\u003c/em\u003e offset \u003cem\u003e\u003cstrong\u003e00Ch (vector 3)\u003c/strong\u003e\u003c/em\u003e and \u003cem\u003e\u003cstrong\u003eTable B-1. VMCB Layout, Control Area (continued)\u003c/strong\u003e\u003c/em\u003e offset \u003cem\u003e\u003cstrong\u003e010h (vector 4)\u003c/strong\u003e\u003c/em\u003e, respectively.\u003c/p\u003e\n\u003cp\u003eThe last part of setting up the Control Area will be to initialize the Msr Permissions Map physical address.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003emsrpm_vmcb_pa = \u003cspan class=\"hljs-built_in\"\u003eMmGetPhysicalAddress\u003c/span\u003e(shared_page_info-\u003emsrpm_addr).QuadPart;\nvcpu_data-\u003eguest_vmcb.control_area.msrpm_base_pa = msrpm_vmcb_pa;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e— Save State - Registers / Descriptor Table Registers / Segment Registers\u003c/h3\u003e\n\u003cp\u003eNow that we've set up the Control Area for our VMCB, we'll start setting up the Save State by initialization the Control Registers, MSRs, and general-purpose registers.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003evcpu_data-\u003eguest_vmcb.save_state.cr0 = \u003cspan class=\"hljs-built_in\"\u003euint64_t\u003c/span\u003e(__readcr0());\nvcpu_data-\u003eguest_vmcb.save_state.cr2 = \u003cspan class=\"hljs-built_in\"\u003euint64_t\u003c/span\u003e(__readcr2());\nvcpu_data-\u003eguest_vmcb.save_state.cr3 = \u003cspan class=\"hljs-built_in\"\u003euint64_t\u003c/span\u003e(__readcr3());\nvcpu_data-\u003eguest_vmcb.save_state.cr4 = \u003cspan class=\"hljs-built_in\"\u003euint64_t\u003c/span\u003e(__readcr4());\nvcpu_data-\u003eguest_vmcb.save_state.efer = \u003cspan class=\"hljs-built_in\"\u003euint64_t\u003c/span\u003e(__readmsr(ia32_efer));\n\n\u003cspan class=\"hljs-comment\"\u003e// GP Register (where they're suppose to be initialize)\u003c/span\u003e\nvcpu_data-\u003eguest_vmcb.save_state.rsp = host_info.rsp;\nvcpu_data-\u003eguest_vmcb.save_state.rip = host_info.rip;\nvcpu_data-\u003eguest_vmcb.save_state.rflags = host_info.eflag;\n\n\u003cspan class=\"hljs-comment\"\u003e// https://en.wikipedia.org/wiki/Page_attribute_table\u003c/span\u003e\nvcpu_data-\u003eguest_vmcb.save_state.g_pat = __readmsr(ia32_pat)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, there's a struct that's being passed to the \"GP Register\" section called \u003ccode\u003ehost_info\u003c/code\u003e. This was initialize before calling the \u003ccode\u003evmcb_initialization(...)\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eAfter initialization Control Registers, MSRs, and general purpose registers, we'll start working on the Descriptor Table Registers and Segment Registers.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003evcpu_data-\u003eguest_vmcb.save_state.gdtr.base_addr = gdtr_ptr.base;\nvcpu_data-\u003eguest_vmcb.save_state.gdtr.limit = gdtr_ptr.limit;\n\nvcpu_data-\u003eguest_vmcb.save_state.idtr.base_addr = idtr_ptr.base;\nvcpu_data-\u003eguest_vmcb.save_state.idtr.limit = idtr_ptr.limit;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe're storing the base and limit of GDT \u0026#x26; IDT registers, into the proper data members of the Save State.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003evcpu_data-\u003eguest_vmcb.save_state.es.limit = __segmentlimit(__reades());\nvcpu_data-\u003eguest_vmcb.save_state.cs.limit = __segmentlimit(__readcs());\nvcpu_data-\u003eguest_vmcb.save_state.ss.limit = __segmentlimit(__readss());\nvcpu_data-\u003eguest_vmcb.save_state.ds.limit = __segmentlimit(__readds());\nvcpu_data-\u003eguest_vmcb.save_state.fs.limit = __segmentlimit(__readfs());\nvcpu_data-\u003eguest_vmcb.save_state.gs.limit = __segmentlimit(__readgs());\n\nvcpu_data-\u003eguest_vmcb.save_state.es.selector = __reades();\nvcpu_data-\u003eguest_vmcb.save_state.cs.selector = __readcs();\nvcpu_data-\u003eguest_vmcb.save_state.ss.selector = __readss();\nvcpu_data-\u003eguest_vmcb.save_state.ds.selector = __readds();\nvcpu_data-\u003eguest_vmcb.save_state.fs.selector = __readfs();\nvcpu_data-\u003eguest_vmcb.save_state.gs.selector = __readgs();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSetting up each segment registers limit and selector for the guest to use.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e [es_base, es_attr] = seg::\u003cspan class=\"hljs-built_in\"\u003esegment_info\u003c/span\u003e(gdtr_ptr, __reades());\nvcpu_data-\u003eguest_vmcb.save_state.es.base_addr = es_base;\nvcpu_data-\u003eguest_vmcb.save_state.es.attribute.value = es_attr;\n\n\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e [cs_base, cs_attr] = seg::\u003cspan class=\"hljs-built_in\"\u003esegment_info\u003c/span\u003e(gdtr_ptr, __readcs());\nvcpu_data-\u003eguest_vmcb.save_state.cs.base_addr = cs_base;\nvcpu_data-\u003eguest_vmcb.save_state.cs.attribute.value = cs_attr;\n\n\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e [ss_base, ss_attr] = seg::\u003cspan class=\"hljs-built_in\"\u003esegment_info\u003c/span\u003e(gdtr_ptr, __readss());\nvcpu_data-\u003eguest_vmcb.save_state.ss.base_addr = ss_base;\nvcpu_data-\u003eguest_vmcb.save_state.ss.attribute.value = ss_attr;\n\n\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e [ds_base, ds_attr] = seg::\u003cspan class=\"hljs-built_in\"\u003esegment_info\u003c/span\u003e(gdtr_ptr, __readds());\nvcpu_data-\u003eguest_vmcb.save_state.ds.base_addr = ds_base;\nvcpu_data-\u003eguest_vmcb.save_state.ds.attribute.value = ds_attr;\n\n\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e [fs_base, fs_attr] = seg::\u003cspan class=\"hljs-built_in\"\u003esegment_info\u003c/span\u003e(gdtr_ptr, __readfs());\nvcpu_data-\u003eguest_vmcb.save_state.fs.base_addr = fs_base;\nvcpu_data-\u003eguest_vmcb.save_state.fs.attribute.value = fs_attr;\n\n\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e [gs_base, gs_attr] = seg::\u003cspan class=\"hljs-built_in\"\u003esegment_info\u003c/span\u003e(gdtr_ptr, __readgs());\nvcpu_data-\u003eguest_vmcb.save_state.gs.base_addr = gs_base;\nvcpu_data-\u003eguest_vmcb.save_state.gs.attribute.value = gs_attr;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will be the last part of setting up the segment and descriptor registers.\u003c/p\u003e\n\u003cp\u003eWe'll start setting up physical addresses for later use. These data members will be passed through our #VMEXIT handler.\nfor the \u003ccode\u003ehost_vmcb_pa\u003c/code\u003e load some host state that are not loaded on #VMEXIT, which you can see in \u003ca href=\"https://github.com/wizardengineer/krakensvm-mg/blob/2980e86d3885a7083e53ee9b445f40713783e1b5/krakensvm/svm/vmexit_handler.cpp#L281\"\u003ehere\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003ehost_vmcb_pa  = \u003cspan class=\"hljs-built_in\"\u003eMmGetPhysicalAddress\u003c/span\u003e(\u0026#x26;vcpu_data-\u003ehost_vmcb).QuadPart;\nguest_vmcb_pa = \u003cspan class=\"hljs-built_in\"\u003eMmGetPhysicalAddress\u003c/span\u003e(\u0026#x26;vcpu_data-\u003eguest_vmcb).QuadPart;\n\nvcpu_data-\u003eguest_vmcb_pa = guest_vmcb_pa;\nvcpu_data-\u003ehost_vmcb_pa  = host_vmcb_pa;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eyou can read in my \u003ca href=\"https://github.com/wizardengineer/krakensvm-mg/blob/f16cb6d2676490be1e1025da976da1d4d99fe62c/krakensvm/svm/vmexecute.asm#L76-L97\"\u003evmexecute.asm\u003c/a\u003e why the \u003ccode\u003eguest_vmcb_pa\u003c/code\u003e was needed to be pass through in \u003ccode\u003evcpu_data\u003c/code\u003e data structure, to give you an idea on how you'd approach doing utilizing \u003ccode\u003eguest_vmcb_pa\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpu\"\u003e    __svm_vmsave(guest_vmcb_pa);\n   __writemsr(vm_hsave_pa, MmGetPhysicalAddress(\u0026#x26;vcpu_data-\u003ehost_state_area).QuadPart);\n   __svm_vmsave(host_vmcb_pa);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we'll do a vmsave to restore a subset of cpu information to the processor right before #VMEXIT with the VMLOAD instruction so that the guest can start its execution with saved state. The we write to VM_HSAVE_PA, to assure that the host can resume operation after #VMEXIT. VMRUN saves a subset of host processor state to the host state-save area specified by the physical address in the VM_HSAVE_PA MSR.\u003c/p\u003e\n\u003cp\u003eLast we'll save some of the current state to VMCB for the host usage. Keep in mind this is loaded after #VMEXIT to reproduce the current state for the host (VMM).\u003c/p\u003e\n\u003ch2\u003eSetting EFER.SVME\u003c/h2\u003e\n\u003cp\u003eThis is fairly simple, all we'll need to do is set the 13 bit of EFER (if we're counting starting from 1) which is EFER.SVME. In other words (1UL \u0026#x3C;\u0026#x3C; 12).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e__writemsr(ia32_efer, __readmsr(ia32_efer) | ia32_efer_svme);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSecure Virtual Machine (SVM) - Instruction Set\u003c/h2\u003e\n\u003cp\u003eSVM has introduces the following instructions.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eAmd Mnemonic\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eVMRUN\u003c/td\u003e\n\u003ctd\u003ePerforms a world-switch to guest\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eVMLOAD\u003c/td\u003e\n\u003ctd\u003eLoad additional state from VMCB.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eVMSAVE\u003c/td\u003e\n\u003ctd\u003eSave additional guest state to VMCB.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCLGI\u003c/td\u003e\n\u003ctd\u003eClears the global interupt flag (GIF).\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eVMMCALL\u003c/td\u003e\n\u003ctd\u003eProvides a mechanism for a guest to explicitly  communicate with the VMM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eINVLPGA\u003c/td\u003e\n\u003ctd\u003eInvalidates the TLB mapping for the  virtual page specified in rAX and the ASID specified in ECX.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSKINIT\u003c/td\u003e\n\u003ctd\u003eDesigned to allows for verifiable startup of  trusted software (such as a VMM), based on  secure hash comparison\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSTGI\u003c/td\u003e\n\u003ctd\u003eThe STGI instruction sets the global interrupt  flag (GIF) to 1.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eVMSAVE Visual Representation\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/wizardengineer/krakensvm-mg/main/img/vmsave.drawio.png\" alt=\"VMSAVE\"\u003e\u003c/p\u003e\n\u003ch3\u003eVMRUN Visual Representation\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/wizardengineer/krakensvm-mg/main/img/IntroducingBluePill.ppt.pdf.png\" alt=\"VMRUN\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/wizardengineer/krakensvm-mg\"\u003eKrakenSvm Project\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eCredit - Special Thanks:\u003c/h2\u003e\n\u003cp\u003eThanks to these OGs, for the spark of inspiration/support and just being good friends/acquaintances overall on my continuous effort on this project and for helping me understand certain concepts within HyperVisor development Journey. =)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://twitter.com/_xeroxz?lang=en\"\u003exeroxz\u003c/a\u003e - Helping explain concepts around HV and allowing me to post my article on his website\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://twitter.com/daax_rynd\"\u003eDaax\u003c/a\u003e - His big brain coming in clutch like always. He's given me a great layout on the semantics of a AMD HyperVisor and his approach on it, sharing resources left and right. Even answered my most trivial questions. Daax never misses\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ehorsie\u003c/strong\u003e - sharing some resource\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/tandasat/SimpleSvm/\"\u003etandasat\u003c/a\u003e - Amazing resource\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/irql0\"\u003eIrql0\u003c/a\u003e - explaining certain Windows kernel driver, OS concepts and getting me out of tough assembly problems\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/iPower\"\u003eiPower\u003c/a\u003e - sharing an approach to hooking System Calls and helping fix my VMCB issues\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/not-matthias\"\u003eMatthias\u003c/a\u003e - For providing information that lead me on to fixing a VMEXIT_INVALID bug i came across and for going out of his way to even debug my HyperVisor to point logic issues and errors. Thank you so much\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#https://github.com/LilPidgey\"\u003eSnowua\u003c/a\u003e for helping proof read this article.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eReference - Resource I relied on:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://developer.amd.com/wordpress/media/2012/10/254811.pdf\"\u003eAMD CPUID Specification\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.amd.com/system/files/TechDocs/24593.pdf\"\u003eAMD Manual\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www-archive.xenproject.org/files/Xen_PacificaDisclosure_AMD_EWahlig.pdf\"\u003eAMD Pacifica Docs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html\"\u003eIntel Manual\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://githacks.org/_xeroxz/bluepill\"\u003eXeroxz Hypervisor\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/irql0/limevisor\"\u003eIrql Hypervisor\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://performancebydesign.blogspot.com/2017/12/hyper-v-architecture-intercepts.html\"\u003eVMM Intercepts\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nskernel.gitbook.io/kernel-play-guide/kvm/amd-v-and-sev\"\u003eKernel Play Guide - AMD-V\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.n4r1b.com/posts/2019/03/system-calls-on-windows-x64/\"\u003eSystem calls on Windows x64\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.matteomalvica.com/minutes/windows_kernel/\"\u003e[windows] kernel internals\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"article\",null,{\"className\":\"py-12\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-5xl font-semibold mb-2\",\"children\":\"AMD-V Hypervisor Development - A Brief Explanation\"}],[\"$\",\"div\",null,{\"className\":\"text-gray-500 mb-8\",\"children\":\"Aug 22, 2022\"}],[\"$\",\"div\",null,{\"className\":\"prose prose-lg\",\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n9:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Wizard Engineer\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Julius’s blog about compilers, security, engineering \u0026 more\"}],[\"$\",\"link\",\"4\",{\"rel\":\"shortcut icon\",\"href\":\"/wizard.svg\"}],[\"$\",\"link\",\"5\",{\"rel\":\"icon\",\"href\":\"/wizard.svg\",\"type\":\"image/svg+xml\"}]]\n3:null\n"])</script></body></html>