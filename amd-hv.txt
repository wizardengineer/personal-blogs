3:I[4707,[],""]
5:I[6423,[],""]
6:I[8911,["972","static/chunks/972-5ecfbe0c89e84126.js","185","static/chunks/app/layout-6ab51d7da38697aa.js"],"default"]
4:["slug","amd-hv","d"]
0:["qhiMpy3rTdIAItkiruPm1",[[["",{"children":[["slug","amd-hv","d"],{"children":["__PAGE__?{\"slug\":\"amd-hv\"}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","amd-hv","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/a3c9030828aa324d.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"antialiased","children":[["$","$L6",null,{}],["$","main",null,{"className":"max-w-3xl mx-auto px-4 py-8","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]}]],null],null],["$L7",null]]]]
8:T964b,<h2>Motativation</h2>
<p>This was apart of my "Understanding of OS theoretical concepts" and emulator series. I enjoy my time with this project, if you're interested in AMD virtualization then read chapter 15 of the AMD manual. There was also a lack of complacent, with the amount of menial projects I've accomplished. I wanted to hit the bigger fish, something more precedence than my former projects, that was going to be considerable harder. I hope this was helpful for any others whom might decide to make an AMD Hypervisor.</p>
<p><a href="https://github.com/wizardengineer/krakensvm-mg">KrakenSvm Project</a></p>
<h2>Table of Contents:</h2>
<ul>
<li><a href="#preamble">Preamble</a>
<ul>
<li><a href="#purpose--intentions">Purpose &#x26; Intentions</a></li>
<li><a href="#support">Support</a></li>
</ul>
</li>
<li><a href="#terminology">Terminology</a></li>
</ul>
<ul>
<li><a href="#overview---krakensvm-hypervisor">Overview - KrakenSvm Hypervisor</a>
<ul>
<li><a href="#virtual-machine-control-block-vmcb---parts">Virtual Machine Control Block (VMCB) - Parts</a>
<ul>
<li><a href="#control-area">Control Area</a></li>
<li><a href="#save-state-area">Save State Area</a></li>
</ul>
</li>
<li><a href="#secure-virtual-machine-svm---semantics">Secure Virtual Machine (SVM) - Semantics</a>
<ul>
<li><a href="#checking-locksupport-bits">Checking Lock/Support Bits</a></li>
<li><a href="#initializing-vmcb">Initializing VMCB</a></li>
<li><a href="#setting-efersvme">Setting EFER.SVME</a></li>
</ul>
</li>
<li><a href="#secure-virtual-machine-svm---instruction-set">Secure Virtual Machine (SVM) - Instruction Set</a></li>
</ul>
</li>
<li><a href="#credit---special-thanks">Credit - Special Thanks</a></li>
<li><a href="#reference---resource-i-relied-on">Reference - Resource I relied on</a></li>
</ul>
<h1>Preamble</h1>
<h2>Purpose &#x26; Intentions</h2>
<p>There wasn't many, if any amd hypervisors, therefore I created a Proof Of Concept for educational purposes. There was a lack of resource to start someone off on the right foot. This project was to at least help subside any hardship that'll come from a lack resource to rely on.</p>
<h2>Support</h2>
<p>To test on VMWare make sure to turn off Hyper-v on main OS and enable Nested Virtualization on VMWare guest machine if you want to test KrakenSvm.</p>
<h1>Terminology</h1>
<ul>
<li><strong>Guest</strong> - The guest is the virtual machine that will be running on the Hypervisor.</li>
<li><strong>Host</strong> - When Host is used, it's referring the execution context of the Hypervisor.</li>
<li><strong>World Switch</strong> - is the act of switching between Host and Guest. The host will excute VMRUN to start-up or run the Guest. The sequence would usually be Host -> Guest -> Host</li>
<li><strong>vCPUs or CPUs</strong> - when the intel or amd manual discusses about a VMM having a CPUs. It's referring to it having CPU Cores, rather than a single entity CPU.</li>
<li><strong>Nest Page Table (NPT)</strong> - "Nested paging eliminates the overhead caused by VM exits and page table accesses. In essence, with nested page tables the guest can handle paging without intervention from the hypervisor. Nested paging thus significantly improves virtualization performance." By <a href="https://docs.oracle.com/en/virtualization/virtualbox/6.0/admin/nestedpaging.html">OracleÂ® VM VirtualBox</a></li>
<li><strong>Intercepting</strong> - In terms of Hypervisors, intercepting is the concept and process of having a consistent view of the virtual processor that is visible to the Guest OS. Any intercept that happens triggers a #VMEXIT on the Guest.</li>
</ul>
<blockquote>
<p>Various instructions and events (such as exceptions) in the
guest can be intercepted by means of control bits in the VMCB.
The two primary classes of intercepts supported by SVM are
instruction and exception intercepts.</p>
</blockquote>
<ul>
<li><strong>Virtual Memory Control Block (VMCB)</strong> - Hold information for the VMM and the Guest For intel this would be called VMCS</li>
<li><strong>Virtual Machine Monitor (VMM)</strong> - "also known as a hypervisor, consists of software that controls the execution of multiple guest operating systems on a single physical machine." By <a href="https://www.amd.com/system/files/TechDocs/24593.pdf">AMD Manual</a></li>
</ul>
<h1>Overview - KrakenSvm Hypervisor</h1>
<p>A simple overview of the Hypervisor Kraken to describe the virtualization process on AMD-v.</p>
<h2>Virtual Machine Control Block (VMCB) - Parts</h2>
<p>The VMCB is a data structure that holds crucial information and data, such as the CPU state and VMM (or Hypervisor) Information that'll correlate to how the Guest operates. Here's a simple VMCB Overview:</p>
<p>The definition of a VMCB Structure:</p>
<p><em>Linux Struct</em></p>
<pre><code class="hljs language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__attribute__</span> ((__packed__)) <span class="hljs-type">vmcb_fmt_t</span> 
{
    <span class="hljs-type">control_area_64_t</span> control_area;
    <span class="hljs-type">save_state_64_t</span>   save_state;
};
</code></pre>
<p><em>Windows Struct</em></p>
<pre><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vmcb_fmt_t</span> 
{
    <span class="hljs-type">control_area_64_t</span> control_area;
    <span class="hljs-type">save_state_64_t</span>   save_state;
    <span class="hljs-type">uint8_t</span> reserved[RESERVED_SIZE];
};
</code></pre>
<h2>Control Area</h2>
<p>The Control Area is the data structure that holds and saves information for the Hypervisor. This data structure will determine the heuristic executions and rules for the Guest. For example, the initiation of intercepts will be held in the Intercept data members as bits, in the context of VMCB Initialization, before we even start virtualizing the CPUs. Along with other crucial information like the EXITCODE, that'll describe how and why a #VMEXIT was caused, after, or within the instant of virtualizing the CPUs.</p>
<p><em>Control Area Structure Overview</em></p>
<pre><code class="hljs language-cpp">  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Table B-1. VMCB Layout, Control Area.</span>
  <span class="hljs-comment">//</span>

  <span class="hljs-keyword">typedef</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_control_area_fmt_t</span>
  {
    <span class="hljs-type">_control_area_fmt_t</span>() = <span class="hljs-keyword">default</span>;
    
    <span class="hljs-keyword">union</span>
    {
      <span class="hljs-type">uint64_t</span> intercept_read_cr0  : <span class="hljs-number">16</span>;      <span class="hljs-comment">// +0x000</span>
      <span class="hljs-type">uint64_t</span> intercept_write_cr0 : <span class="hljs-number">16</span>;      <span class="hljs-comment">// +0x002</span>
      <span class="hljs-type">uint64_t</span> intercept_read_dr0  : <span class="hljs-number">16</span>;      <span class="hljs-comment">// +0x004</span>
      <span class="hljs-type">uint64_t</span> intercept_write_dr0 : <span class="hljs-number">16</span>;      <span class="hljs-comment">// +0x006</span>
    };
  
    <span class="hljs-type">uint32_t</span> intercept_exceptions_vector;     <span class="hljs-comment">// +0x008</span>
    <span class="hljs-type">uint32_t</span> intercept_misc_vector_3;         <span class="hljs-comment">// +0x00c</span>
    <span class="hljs-type">uint32_t</span> intercept_misc_vector_4;         <span class="hljs-comment">// +0x010</span>
   
    <span class="hljs-type">uint32_t</span> intercept_misc_vector_5 : <span class="hljs-number">5</span>;     <span class="hljs-comment">// +0x014</span>
    <span class="hljs-type">uint32_t</span> reserved_sbz_1          : <span class="hljs-number">27</span>;
   

    <span class="hljs-type">uint8_t</span> reserved[<span class="hljs-number">0x3b</span> - <span class="hljs-number">0x18</span>];            <span class="hljs-comment">// +0x018â0x03b</span>

    <span class="hljs-type">uint16_t</span> pause_filter_threshold;          <span class="hljs-comment">// +0x03c</span>
    <span class="hljs-type">uint16_t</span> pause_filter_count;              <span class="hljs-comment">// +0x03e</span>

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Physical base address of IOPM (bits 11:0 are ignored.)</span>
    <span class="hljs-comment">// </span>
    
    <span class="hljs-type">uint64_t</span> iopm_base_pa;                    <span class="hljs-comment">// +0x040</span>

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Physical base address of MSRPM (bits 11:0 are ignored.)</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-type">uint64_t</span> msrpm_base_pa;                   <span class="hljs-comment">// +0x048</span>

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// TSC_OFFSET To be added in RDTSC and RDTSCP</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-type">uint64_t</span> tsc_offset;                      <span class="hljs-comment">// +0x050</span>

    <span class="hljs-type">uint64_t</span> guest_asid     : <span class="hljs-number">32</span>;             <span class="hljs-comment">// +0x058</span>
    <span class="hljs-type">uint64_t</span> tlb_control    : <span class="hljs-number">8</span>;
    <span class="hljs-type">uint64_t</span> reserved_sbz_2 : <span class="hljs-number">24</span>;

    <span class="hljs-type">uint64_t</span> virtual_misc_vector;             <span class="hljs-comment">// +0x060</span>
    <span class="hljs-type">uint64_t</span> interrupt_misc_vector;           <span class="hljs-comment">// +0x068</span>
    <span class="hljs-type">uint64_t</span> exitcode;                        <span class="hljs-comment">// +0x070</span>
    <span class="hljs-type">uint64_t</span> exitinfo1;                       <span class="hljs-comment">// +0x078</span>
    <span class="hljs-type">uint64_t</span> exitinfo2;                       <span class="hljs-comment">// +0x080</span>
    <span class="hljs-type">uint64_t</span> exitintinfo;                     <span class="hljs-comment">// +0x088</span>

    <span class="hljs-type">uint64_t</span> enable_misc_vector;              <span class="hljs-comment">// +0x090</span>
    <span class="hljs-type">uint64_t</span> avic_apic_bar;                   <span class="hljs-comment">// +0x098</span>
    <span class="hljs-type">uint64_t</span> guest_pa_ghcb;                   <span class="hljs-comment">// +0x0a0</span>
    <span class="hljs-type">uint64_t</span> eventinj;                        <span class="hljs-comment">// +0x0a8</span>
    <span class="hljs-type">uint64_t</span> nested_page_cr3;                 <span class="hljs-comment">// +0x0b0</span>
    <span class="hljs-type">uint64_t</span> lbr_virtualization_enable;       <span class="hljs-comment">// +0x0b8</span>

    clean_field vmcb_clean_bits;              <span class="hljs-comment">// +0x0c0</span>
    

    <span class="hljs-type">uint64_t</span> n_rip;                           <span class="hljs-comment">// +0x0c8</span>

    <span class="hljs-type">uint8_t</span> numbers_bytes_fetched;            <span class="hljs-comment">// +0x0d0</span>
    <span class="hljs-type">uint8_t</span> guest_intruction_bytes[<span class="hljs-number">15</span>];

    <span class="hljs-type">uint64_t</span> avic_apic_backing_page_pointer;  <span class="hljs-comment">// +0x0e0</span>
    <span class="hljs-type">uint64_t</span> reserved_sbz_3;                  <span class="hljs-comment">// +0x0e8</span>
    <span class="hljs-type">uint64_t</span> avic_logical_table_pointer;      <span class="hljs-comment">// +0x0f0</span>
    <span class="hljs-type">uint64_t</span> avic_physical_table_pointer;     <span class="hljs-comment">// +0x0f8</span>
    <span class="hljs-type">uint64_t</span> reserved_sbz_4;                  <span class="hljs-comment">// +0x100</span>
    <span class="hljs-type">uint64_t</span> vmsa_pointer;                    <span class="hljs-comment">// +0x108</span>
    <span class="hljs-type">uint8_t</span> reserved_sbz_5[<span class="hljs-number">0x400</span> - <span class="hljs-number">0x110</span>];

  } <span class="hljs-type">control_area_64_t</span>, *<span class="hljs-type">pcontrol_area_64_t</span>;
</code></pre>
<h2>Save State Area</h2>
<p>The Save State Area would usually be the second data structure in the VMCB struct. Save State Area holds a subset of our processor state/information for the Guest, that's either being loaded from the VMCB or saved to the VMCB. These acts are derived from <a href="#secure-virtual-machine-svm---instruction-set">VMLOAD</a> and <a href="#secure-virtual-machine-svm---instruction-set">VMSAVE</a> respectively.</p>
<p><em>Save State Area</em></p>
<pre><code class="hljs language-cpp">  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Table B-2. VMCB Layout, State Save Area</span>
  <span class="hljs-comment">//</span>

  <span class="hljs-keyword">typedef</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_save_state_fmt_t</span>
  {
    <span class="hljs-type">_save_state_fmt_t</span>() = <span class="hljs-keyword">default</span>;

    seg_register es;                          <span class="hljs-comment">// +0x000</span>
    seg_register cs;                          <span class="hljs-comment">// +0x010</span>
    seg_register ss;                          <span class="hljs-comment">// +0x020</span>
    seg_register ds;                          <span class="hljs-comment">// +0x030</span>
    seg_register fs;                          <span class="hljs-comment">// +0x040</span>
    seg_register gs;                          <span class="hljs-comment">// +0x050</span>
    seg_register gdtr;                        <span class="hljs-comment">// +0x060</span>
    seg_register ldtr;                        <span class="hljs-comment">// +0x070</span>
    seg_register idtr;                        <span class="hljs-comment">// +0x080</span>
    seg_register tr;                          <span class="hljs-comment">// +0x090</span>

    <span class="hljs-type">uint8_t</span> reserved1[<span class="hljs-number">0xca</span> - <span class="hljs-number">0xa0</span>];           <span class="hljs-comment">// +0x0a0</span>
    <span class="hljs-type">uint8_t</span> cpl;                              <span class="hljs-comment">// +0x0cb</span>
    <span class="hljs-type">uint32_t</span> reserved2;                       <span class="hljs-comment">// +0x0cc</span>
    <span class="hljs-type">uint64_t</span> efer;                            <span class="hljs-comment">// +0x0d0</span>
    <span class="hljs-type">uint8_t</span> reserved3[<span class="hljs-number">0x147</span> - <span class="hljs-number">0xd8</span>];          <span class="hljs-comment">// +0x0d9</span>
    <span class="hljs-type">uint64_t</span> cr4;                             <span class="hljs-comment">// +0x148</span>
    <span class="hljs-type">uint64_t</span> cr3;                             <span class="hljs-comment">// +0x150</span>
    <span class="hljs-type">uint64_t</span> cr0;                             <span class="hljs-comment">// +0x158</span>
    <span class="hljs-type">uint64_t</span> dr7;                             <span class="hljs-comment">// +0x160</span>
    <span class="hljs-type">uint64_t</span> dr6;                             <span class="hljs-comment">// +0x168</span>
    <span class="hljs-type">uint64_t</span> rflags;                          <span class="hljs-comment">// +0x170</span>
    <span class="hljs-type">uint64_t</span> rip;                             <span class="hljs-comment">// +0x178</span>
    <span class="hljs-type">uint8_t</span> reserved4[<span class="hljs-number">0x1d7</span> - <span class="hljs-number">0x180</span>];         <span class="hljs-comment">// +0x180</span>
    <span class="hljs-type">uint64_t</span> rsp;                             <span class="hljs-comment">// +0x1d8</span>
    <span class="hljs-type">uint64_t</span> s_cet;                           <span class="hljs-comment">// +0x1e0</span>
    <span class="hljs-type">uint64_t</span> ssp;                             <span class="hljs-comment">// +0x1e8</span>
    <span class="hljs-type">uint64_t</span> isst_addr;                       <span class="hljs-comment">// +0x1f0</span>
    <span class="hljs-type">uint64_t</span> rax;                             <span class="hljs-comment">// +0x1f8</span>
    <span class="hljs-type">uint64_t</span> star;                            <span class="hljs-comment">// +0x200</span>
    <span class="hljs-type">uint64_t</span> lstar;                           <span class="hljs-comment">// +0x208</span>
    <span class="hljs-type">uint64_t</span> cstar;                           <span class="hljs-comment">// +0x210</span>
    <span class="hljs-type">uint64_t</span> sfmask;                          <span class="hljs-comment">// +0x218</span>
    <span class="hljs-type">uint64_t</span> kernel_gs_base;                  <span class="hljs-comment">// +0x220</span>
    <span class="hljs-type">uint64_t</span> sysenter_cs;                     <span class="hljs-comment">// +0x228</span>
    <span class="hljs-type">uint64_t</span> sysenter_esp;                    <span class="hljs-comment">// +0x230</span>
    <span class="hljs-type">uint64_t</span> sysenter_eip;                    <span class="hljs-comment">// +0x238</span>
    <span class="hljs-type">uint64_t</span> cr2;                             <span class="hljs-comment">// +0x240</span>
    <span class="hljs-type">uint8_t</span> reserved5[<span class="hljs-number">0x267</span> - <span class="hljs-number">0x248</span>];         <span class="hljs-comment">// +0x248</span>
    <span class="hljs-type">uint64_t</span> g_pat;                           <span class="hljs-comment">// +0x268</span>
    <span class="hljs-type">uint64_t</span> dbg_ctrl;                        <span class="hljs-comment">// +0x270</span>
    <span class="hljs-type">uint64_t</span> br_from;                         <span class="hljs-comment">// +0x278</span>
    <span class="hljs-type">uint64_t</span> br_to;                           <span class="hljs-comment">// +0x280</span>
    <span class="hljs-type">uint64_t</span> last_excp_from;                  <span class="hljs-comment">// +0x288</span>
    <span class="hljs-type">uint8_t</span> reserved6[<span class="hljs-number">0x2df</span> - <span class="hljs-number">0x298</span>];         <span class="hljs-comment">// +0x298</span>
    <span class="hljs-type">uint64_t</span> spec_ctrl;                       <span class="hljs-comment">// +0x2e0</span>
    <span class="hljs-type">uint32_t</span> reserved7;                       <span class="hljs-comment">// +0x2e4</span>

  } <span class="hljs-type">save_state_64_t</span>, *<span class="hljs-type">psave_state_64_t</span>;
</code></pre>
<h1>Secure Virtual Machine (SVM) - Semantics</h1>
<p>This isn't the full semantics of an AMD Hypervisor that you'd see in the manual. This will be a brief and small explanation of creating a VMM for AMD CPUs and how I went about making mine. For the sake of not prolonging this article, I omitted some things, such as in-detail memory allocation, MSR Bitmap setup, and other things that can be easily researched.</p>
<h2>Checking Lock/Support Bits</h2>
<p>These bits which are either accessed through an MSR or CPUID determine if the CPU is properly set for virtualization to be supported and doesn't have anything that'll lock or render us incapable of enabling virtualization. Let's look at pseudo-code to understand the algorithm for checking each lock and support bits:
</p>
<pre><code class="hljs language-c">Fn8000_0001_ECX_SVM = (<span class="hljs-number">1UL</span> &#x3C;&#x3C; <span class="hljs-number">2</span>);
Fn8000_000A_EDX_NP  = (<span class="hljs-number">1UL</span> &#x3C;&#x3C; <span class="hljs-number">0</span>);
Fn8000_000A_EDX_SVML= (<span class="hljs-number">1UL</span> &#x3C;&#x3C; <span class="hljs-number">2</span>);
MSR_VM_CR           = <span class="hljs-number">0xC0010114</span>;


<span class="hljs-type">int32_t</span> registers[<span class="hljs-number">4</span>]; <span class="hljs-comment">// Index 0 = EAX, </span>
                      <span class="hljs-comment">// Index 1 = EBX, </span>
		      <span class="hljs-comment">// Index 2 = ECX, </span>
		      <span class="hljs-comment">// Index 3 = EDX</span>

<span class="hljs-comment">// checks to see if the processor supports SVM.</span>
<span class="hljs-comment">// See "SVM: secure virtual machine" in </span>
<span class="hljs-comment">// "CPUID Fn8000_0001_ECX[WDT, SKINIT, OSVW, 3DNowPrefetch, MisAlignSse, SSE4A, ABM, ExtApicSpace]"</span>
<span class="hljs-comment">//</span>
__cpuid(registers, Fn8000_0001_ECX);
<span class="hljs-keyword">if</span> ( (registers[<span class="hljs-number">2</span>] &#x26; Fn8000_0001_ECX_SVM) == <span class="hljs-number">0</span> )
	<span class="hljs-keyword">return</span> SVM_IS_NOT_SUPPORTED_BY_CPU;

<span class="hljs-comment">// checks to see if the processor supports Nested Paging</span>
<span class="hljs-comment">// See "NP: nested paging" in "CPUID Fn8000_000A_EDX[DecodeAssists, FlushByAsid, VmcbClean, TscRateMsr]"</span>
<span class="hljs-comment">//</span>
__cpuid(registers, Fn8000_000A_EDX);
<span class="hljs-keyword">if</span> ( (registers[<span class="hljs-number">3</span>] &#x26; Fn8000_000A_EDX_NP) == <span class="hljs-number">0</span>)
	<span class="hljs-keyword">return</span> SVM_NESTED_PAGING_NOT_SUPPORTED;
	
<span class="hljs-comment">// checks to see if the EFER.SVM can be enabled, if the VM_CR.SVMDIS is set then we can't enable EFER.SVM.</span>
<span class="hljs-keyword">if</span> (__readmsr(vm_cr) &#x26; vm_cr_svmdis) == <span class="hljs-number">0</span>
	<span class="hljs-keyword">return</span> SVM_IS_CAPABLE_OF_BEING_ENABLE;

<span class="hljs-comment">// checks if the user must change a platform firmware setting to enable SVM, if not SVMLock may be unlockable; </span>
<span class="hljs-comment">// consult platform firmware or TPM to obtain the key</span>
<span class="hljs-comment">// See "SVML: SVM lock" in "CPUID Fn8000_000A_EDX[DecodeAssists, FlushByAsid, VmcbClean, TscRateMsr]"</span>
__cpuid(registers, Fn8000_000A_EDX);
<span class="hljs-keyword">if</span> ( (registers[<span class="hljs-number">3</span>] &#x26; Fn8000_000A_EDX_SVML) == <span class="hljs-number">0</span>)
	<span class="hljs-keyword">return</span> SVM_DISABLED_AT_BIOS_NOT_UNLOCKABLE;
<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">return</span> SVM_DISABLED_WITH_KEY;
</code></pre>
<p>We check those bits to determine if our code can continue execution. These bits may not have to check if you are positive that your AMD Processor is up to date and is cable of virtualization; however, I would still recommend checking those bits, for the sake of practicality.
</p>
<h2>Initializing VMCB</h2>
<p>Initializing VMCB is monumental in allowing the Guest and VMM to run properly. The reason we initialize VMCB is to have consistency between the processor state and the guest state. This initialization is the preparation that'll be used for our VMM and Guest execution. This section will be showing the steps of initializing the VMCB. We'll start off by capturing the GDT &#x26; IDT registers, initializing the Guest Intercept fields of the <code>vcpu_data->guest_vmcb.control_area</code> and setting the guest's address space ID (ASID) to 1.</p>
<p>For the following code examples, they'll be stored in <code>vmcb_initialization(...)</code> function.</p>
<p>Lets first demonstrate the code Control Area initialization:</p>
<h3>â Control Area - Interception Fields &#x26; ASID</h3>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_MSR_PROT (1UL &#x3C;&#x3C; 28) <span class="hljs-comment">// MSR_PROTâintercept RDMSR or WRMSR accesses to selected MSRs.</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_CPUID    (1UL &#x3C;&#x3C; 18) <span class="hljs-comment">// Intercept CPUID Instruction.</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_VMRUN    (1UL &#x3C;&#x3C; 0)  <span class="hljs-comment">// Intercept VMRUN instruction.</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_VMMCALL  (1UL &#x3C;&#x3C; 1)  <span class="hljs-comment">// Intercept VMMCALL instruction.</span></span>

<span class="hljs-comment">// This will be explained later on...</span>
<span class="hljs-comment">//</span>
_sgdt(&#x26;gdtr_ptr);
__sidt(&#x26;idtr_ptr);

vcpu_data->guest_vmcb
      .control_area.intercept_misc_vector_3 |= INTERCEPT_MSR_PROT | 
                                               INTERCEPT_CPUID;
vcpu_data->guest_vmcb
      .control_area.intercept_misc_vector_4 |= INTERCEPT_VMRUN;

vcpu_data->guest_vmcb.control_area.guest_asid = <span class="hljs-number">1</span>;
</code></pre>
<p>As you can see, the 32-bit data members <code>intercept_misc_vector_3</code> and <code>intercept_misc_vector_4</code> of Control Area does an OR set certain bits. The data member <code>intercept_misc_vector_3</code> will intercept the <code>INTERCEPT_MSR_PROT</code>and <code>INTERCEPT_CPUID</code>. The first Interception will be used to help determine which MSR will is being rdmsr and wrmsr. This is great because we can filter out which MSR we want to intercept specifically in our MSR Bitmap (that was allocated by the VMM) instead of intercepting every time an MSR rdmsr or wrmsr happens. The second bit that being set is the is <code>INTERCEPT_CPUID</code>, we'll use this interception to help with exiting our Guest and VMM and over the execution in a proper manner. That includes deallocation and giving our host back execution.</p>
<p>Now let's move on to the <code>intercept_misc_vector_4</code> data member. This data member sets the <code>INTERCEPT_VMRUN</code> which is required to be set, otherwise, our Guest won't execute at all. The instruction VMRUN does a Canonicalization and Consistency Checks for guests and #VMEXIT for the host. <code>INTERCEPT_VMRUN</code> not being set is considered to be an illegal guest state combination, subsequently causing a #VMEXIT with error code VMEXIT_INVALID.</p>
<p>The same concept applies to the <code>guest_asid</code>, a consistency check is done to make sure ASID is not set to 0. Otherwise, it'd be considered illegal, causing a #VMEXIT with the error code VMEXIT_INVALID.</p>
<p>You can find the first two data members correspondence in <em><strong>Table B-1. VMCB Layout, Control Area</strong></em> offset <em><strong>00Ch (vector 3)</strong></em> and <em><strong>Table B-1. VMCB Layout, Control Area (continued)</strong></em> offset <em><strong>010h (vector 4)</strong></em>, respectively.</p>
<p>The last part of setting up the Control Area will be to initialize the Msr Permissions Map physical address.</p>
<pre><code class="hljs language-cpp">msrpm_vmcb_pa = <span class="hljs-built_in">MmGetPhysicalAddress</span>(shared_page_info->msrpm_addr).QuadPart;
vcpu_data->guest_vmcb.control_area.msrpm_base_pa = msrpm_vmcb_pa;
</code></pre>
<h3>â Save State - Registers / Descriptor Table Registers / Segment Registers</h3>
<p>Now that we've set up the Control Area for our VMCB, we'll start setting up the Save State by initialization the Control Registers, MSRs, and general-purpose registers.</p>
<pre><code class="hljs language-cpp">vcpu_data->guest_vmcb.save_state.cr0 = <span class="hljs-built_in">uint64_t</span>(__readcr0());
vcpu_data->guest_vmcb.save_state.cr2 = <span class="hljs-built_in">uint64_t</span>(__readcr2());
vcpu_data->guest_vmcb.save_state.cr3 = <span class="hljs-built_in">uint64_t</span>(__readcr3());
vcpu_data->guest_vmcb.save_state.cr4 = <span class="hljs-built_in">uint64_t</span>(__readcr4());
vcpu_data->guest_vmcb.save_state.efer = <span class="hljs-built_in">uint64_t</span>(__readmsr(ia32_efer));

<span class="hljs-comment">// GP Register (where they're suppose to be initialize)</span>
vcpu_data->guest_vmcb.save_state.rsp = host_info.rsp;
vcpu_data->guest_vmcb.save_state.rip = host_info.rip;
vcpu_data->guest_vmcb.save_state.rflags = host_info.eflag;

<span class="hljs-comment">// https://en.wikipedia.org/wiki/Page_attribute_table</span>
vcpu_data->guest_vmcb.save_state.g_pat = __readmsr(ia32_pat)
</code></pre>
<p>As you can see, there's a struct that's being passed to the "GP Register" section called <code>host_info</code>. This was initialize before calling the <code>vmcb_initialization(...)</code> function.</p>
<p>After initialization Control Registers, MSRs, and general purpose registers, we'll start working on the Descriptor Table Registers and Segment Registers.</p>
<pre><code class="hljs language-cpp">vcpu_data->guest_vmcb.save_state.gdtr.base_addr = gdtr_ptr.base;
vcpu_data->guest_vmcb.save_state.gdtr.limit = gdtr_ptr.limit;

vcpu_data->guest_vmcb.save_state.idtr.base_addr = idtr_ptr.base;
vcpu_data->guest_vmcb.save_state.idtr.limit = idtr_ptr.limit;
</code></pre>
<p>We're storing the base and limit of GDT &#x26; IDT registers, into the proper data members of the Save State.</p>
<pre><code class="hljs language-cpp">vcpu_data->guest_vmcb.save_state.es.limit = __segmentlimit(__reades());
vcpu_data->guest_vmcb.save_state.cs.limit = __segmentlimit(__readcs());
vcpu_data->guest_vmcb.save_state.ss.limit = __segmentlimit(__readss());
vcpu_data->guest_vmcb.save_state.ds.limit = __segmentlimit(__readds());
vcpu_data->guest_vmcb.save_state.fs.limit = __segmentlimit(__readfs());
vcpu_data->guest_vmcb.save_state.gs.limit = __segmentlimit(__readgs());

vcpu_data->guest_vmcb.save_state.es.selector = __reades();
vcpu_data->guest_vmcb.save_state.cs.selector = __readcs();
vcpu_data->guest_vmcb.save_state.ss.selector = __readss();
vcpu_data->guest_vmcb.save_state.ds.selector = __readds();
vcpu_data->guest_vmcb.save_state.fs.selector = __readfs();
vcpu_data->guest_vmcb.save_state.gs.selector = __readgs();
</code></pre>
<p>Setting up each segment registers limit and selector for the guest to use.</p>
<pre><code class="hljs language-cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [es_base, es_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __reades());
vcpu_data->guest_vmcb.save_state.es.base_addr = es_base;
vcpu_data->guest_vmcb.save_state.es.attribute.value = es_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [cs_base, cs_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readcs());
vcpu_data->guest_vmcb.save_state.cs.base_addr = cs_base;
vcpu_data->guest_vmcb.save_state.cs.attribute.value = cs_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [ss_base, ss_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readss());
vcpu_data->guest_vmcb.save_state.ss.base_addr = ss_base;
vcpu_data->guest_vmcb.save_state.ss.attribute.value = ss_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [ds_base, ds_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readds());
vcpu_data->guest_vmcb.save_state.ds.base_addr = ds_base;
vcpu_data->guest_vmcb.save_state.ds.attribute.value = ds_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [fs_base, fs_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readfs());
vcpu_data->guest_vmcb.save_state.fs.base_addr = fs_base;
vcpu_data->guest_vmcb.save_state.fs.attribute.value = fs_attr;

<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [gs_base, gs_attr] = seg::<span class="hljs-built_in">segment_info</span>(gdtr_ptr, __readgs());
vcpu_data->guest_vmcb.save_state.gs.base_addr = gs_base;
vcpu_data->guest_vmcb.save_state.gs.attribute.value = gs_attr;

</code></pre>
<p>This will be the last part of setting up the segment and descriptor registers.</p>
<p>We'll start setting up physical addresses for later use. These data members will be passed through our #VMEXIT handler.
for the <code>host_vmcb_pa</code> load some host state that are not loaded on #VMEXIT, which you can see in <a href="https://github.com/wizardengineer/krakensvm-mg/blob/2980e86d3885a7083e53ee9b445f40713783e1b5/krakensvm/svm/vmexit_handler.cpp#L281">here</a></p>
<pre><code class="hljs language-cpp">host_vmcb_pa  = <span class="hljs-built_in">MmGetPhysicalAddress</span>(&#x26;vcpu_data->host_vmcb).QuadPart;
guest_vmcb_pa = <span class="hljs-built_in">MmGetPhysicalAddress</span>(&#x26;vcpu_data->guest_vmcb).QuadPart;

vcpu_data->guest_vmcb_pa = guest_vmcb_pa;
vcpu_data->host_vmcb_pa  = host_vmcb_pa;
</code></pre>
<p>you can read in my <a href="https://github.com/wizardengineer/krakensvm-mg/blob/f16cb6d2676490be1e1025da976da1d4d99fe62c/krakensvm/svm/vmexecute.asm#L76-L97">vmexecute.asm</a> why the <code>guest_vmcb_pa</code> was needed to be pass through in <code>vcpu_data</code> data structure, to give you an idea on how you'd approach doing utilizing <code>guest_vmcb_pa</code>.</p>
<pre><code class="hljs language-cpu">    __svm_vmsave(guest_vmcb_pa);
   __writemsr(vm_hsave_pa, MmGetPhysicalAddress(&#x26;vcpu_data->host_state_area).QuadPart);
   __svm_vmsave(host_vmcb_pa);
</code></pre>
<p>Now, we'll do a vmsave to restore a subset of cpu information to the processor right before #VMEXIT with the VMLOAD instruction so that the guest can start its execution with saved state. The we write to VM_HSAVE_PA, to assure that the host can resume operation after #VMEXIT. VMRUN saves a subset of host processor state to the host state-save area specified by the physical address in the VM_HSAVE_PA MSR.</p>
<p>Last we'll save some of the current state to VMCB for the host usage. Keep in mind this is loaded after #VMEXIT to reproduce the current state for the host (VMM).</p>
<h2>Setting EFER.SVME</h2>
<p>This is fairly simple, all we'll need to do is set the 13 bit of EFER (if we're counting starting from 1) which is EFER.SVME. In other words (1UL &#x3C;&#x3C; 12).</p>
<pre><code class="hljs language-cpp">__writemsr(ia32_efer, __readmsr(ia32_efer) | ia32_efer_svme);
</code></pre>
<h2>Secure Virtual Machine (SVM) - Instruction Set</h2>
<p>SVM has introduces the following instructions.</p>
<table>
<thead>
<tr>
<th>Amd Mnemonic</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>VMRUN</td>
<td>Performs a world-switch to guest</td>
</tr>
<tr>
<td>VMLOAD</td>
<td>Load additional state from VMCB.</td>
</tr>
<tr>
<td>VMSAVE</td>
<td>Save additional guest state to VMCB.</td>
</tr>
<tr>
<td>CLGI</td>
<td>Clears the global interupt flag (GIF).</td>
</tr>
<tr>
<td>VMMCALL</td>
<td>Provides a mechanism for a guest to explicitly  communicate with the VMM</td>
</tr>
<tr>
<td>INVLPGA</td>
<td>Invalidates the TLB mapping for the  virtual page specified in rAX and the ASID specified in ECX.</td>
</tr>
<tr>
<td>SKINIT</td>
<td>Designed to allows for verifiable startup of  trusted software (such as a VMM), based on  secure hash comparison</td>
</tr>
<tr>
<td>STGI</td>
<td>The STGI instruction sets the global interrupt  flag (GIF) to 1.</td>
</tr>
</tbody>
</table>
<h3>VMSAVE Visual Representation</h3>
<p><img src="https://raw.githubusercontent.com/wizardengineer/krakensvm-mg/main/img/vmsave.drawio.png" alt="VMSAVE"></p>
<h3>VMRUN Visual Representation</h3>
<p><img src="https://raw.githubusercontent.com/wizardengineer/krakensvm-mg/main/img/IntroducingBluePill.ppt.pdf.png" alt="VMRUN"></p>
<p><a href="https://github.com/wizardengineer/krakensvm-mg">KrakenSvm Project</a></p>
<h2>Credit - Special Thanks:</h2>
<p>Thanks to these OGs, for the spark of inspiration/support and just being good friends/acquaintances overall on my continuous effort on this project and for helping me understand certain concepts within HyperVisor development Journey. =)</p>
<ul>
<li><a href="https://twitter.com/_xeroxz?lang=en">xeroxz</a> - Helping explain concepts around HV and allowing me to post my article on his website</li>
<li><a href="https://twitter.com/daax_rynd">Daax</a> - His big brain coming in clutch like always. He's given me a great layout on the semantics of a AMD HyperVisor and his approach on it, sharing resources left and right. Even answered my most trivial questions. Daax never misses</li>
<li><strong>horsie</strong> - sharing some resource</li>
<li><a href="https://github.com/tandasat/SimpleSvm/">tandasat</a> - Amazing resource</li>
<li><a href="https://github.com/irql0">Irql0</a> - explaining certain Windows kernel driver, OS concepts and getting me out of tough assembly problems</li>
<li><a href="https://github.com/iPower">iPower</a> - sharing an approach to hooking System Calls and helping fix my VMCB issues</li>
<li><a href="https://github.com/not-matthias">Matthias</a> - For providing information that lead me on to fixing a VMEXIT_INVALID bug i came across and for going out of his way to even debug my HyperVisor to point logic issues and errors. Thank you so much</li>
<li><a href="#https://github.com/LilPidgey">Snowua</a> for helping proof read this article.</li>
</ul>
<h2>Reference - Resource I relied on:</h2>
<ul>
<li><a href="http://developer.amd.com/wordpress/media/2012/10/254811.pdf">AMD CPUID Specification</a></li>
<li><a href="https://www.amd.com/system/files/TechDocs/24593.pdf">AMD Manual</a></li>
<li><a href="http://www-archive.xenproject.org/files/Xen_PacificaDisclosure_AMD_EWahlig.pdf">AMD Pacifica Docs</a></li>
<li><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">Intel Manual</a></li>
<li><a href="https://githacks.org/_xeroxz/bluepill">Xeroxz Hypervisor</a></li>
<li><a href="https://github.com/irql0/limevisor">Irql Hypervisor</a></li>
<li><a href="https://performancebydesign.blogspot.com/2017/12/hyper-v-architecture-intercepts.html">VMM Intercepts</a></li>
<li><a href="https://nskernel.gitbook.io/kernel-play-guide/kvm/amd-v-and-sev">Kernel Play Guide - AMD-V</a></li>
<li><a href="https://www.n4r1b.com/posts/2019/03/system-calls-on-windows-x64/">System calls on Windows x64</a></li>
<li><a href="https://www.matteomalvica.com/minutes/windows_kernel/">[windows] kernel internals</a></li>
</ul>2:["$","article",null,{"className":"py-12","children":[["$","h1",null,{"className":"text-5xl font-semibold mb-2","children":"AMD-V Hypervisor Development - A Brief Explanation"}],["$","div",null,{"className":"text-gray-500 mb-8","children":"Aug 22, 2022"}],["$","div",null,{"className":"prose prose-lg","dangerouslySetInnerHTML":{"__html":"$8"}}]]}]
7:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Wizard Thoughts"}],["$","meta","3",{"name":"description","content":"Juliusâs blog about compilers, security, engineering & more"}],["$","link","4",{"rel":"shortcut icon","href":"/wizard.svg"}],["$","link","5",{"rel":"icon","href":"/wizard.svg","type":"image/svg+xml"}]]
1:null
